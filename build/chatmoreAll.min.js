function chatmoreState(){var h=this;var f=0;var b=31;var e=function(l,k){if(k===undefined){k=2166136261}for(var j=0;j<l.length;j++){k*=16777619;k^=l.charCodeAt(j);k&=4294967295}return k};var d=function(i){for(var j in i){if(i.hasOwnProperty(j)){return false}}return true};h.isModified=false;h.isActivated=false;h.isRegistered=false;h.registrationAttemptCount=0;h.nick=undefined;h.ident=undefined;h.realname=undefined;h.channels={};h.users={};h.lastRecvTime=undefined;h.messageCount=0;h.sessionId=undefined;h.getChannels=function(){var i=[];for(var j in h.channels){i.push(j)}return i};h.getUsers=function(){var j=[];for(var i in h.users){j.push(i)}return j};h.addChannel=function(i){if(h.channels[i]===undefined){h.channels[i]=new g();h.isModified=true}return h.channels[i]};h.addUser=function(i){if(h.users[i]===undefined){h.users[i]=new a();h.isModified=true}return h.users[i]};h.removeChannel=function(i){if(h.channels[i]!==undefined){delete h.channels[i];h.isModified=true}};h.removeUser=function(i){if(h.users[i]!==undefined){delete h.users[i];h.isModified=true}};h.clearChannels=function(){if(!d(h.channels)){h.channels={};h.isModified=true}};h.clearUsers=function(){if(!d(h.users)){h.users={};h.isModified=true}};function g(){this.mode=undefined;this.visibility=undefined;this.topic=undefined;this.topicSetByNick=undefined;this.topicSetTime=undefined;this.members={};this.lastRPL_NAMREPLY=0;this.lastRPL_ENDOFNAMES=0;this.addMember=function(i){if(this.members[i]===undefined){member=new c();member.mode="";nickHash=e(i);member.colorizeNumber=nickHash%(b-f+1)+f;this.members[i]=member;h.isModified=true}return this.members[i]};this.removeMember=function(i){if(this.members[i]!==undefined){delete this.members[i];h.isModified=true}};this.clearMembers=function(){if(!d(this.members)){this.members={};h.isModified=true}}}function c(){this.mode=undefined;this.colorizeNumber=undefined}function a(){this.realname=undefined;this.host=undefined;this.mode=undefined}};function chatmore(d,b){if(b===undefined){b={}}var a=this;var c;c={pollHandle:undefined,pollXhr:undefined,pauseRecv:false,processMessages:function(e){if(e===undefined){return false}a.state.lastRecvTime=new Date().getTime();$.each(e,function(f,h){$(d).trigger("processingMessage.chatmore",[h]);a.state.messageCount++;switch(h.type){case"recv":if(window.console){if(h.raw!==undefined){console.log(h.raw)}console.log(h)}switch(h.command){case"JOIN":if(a.state.channels[h.info.channel]===undefined){a.state.addChannel(h.info.channel);a.sendMsg("MODE "+h.info.channel)}a.state.channels[h.info.channel].addMember(h.prefixNick);break;case"PART":if(a.stricmp(h.prefixNick,a.state.nick)===0){a.state.removeChannel(h.info.channel)}else{a.state.channels[h.info.channel].removeMember(h.prefixNick)}break;case"KICK":$.each(h.info.kicks,function(j,k){if(a.stricmp(k.nick,a.state.nick)===0){a.state.removeChannel(k.channel)}else{a.state.channels[k.channel].removeMember(k.nick)}});break;case"MODE":if(a.isChannel(h.info.target)){if(a.state.channels[h.info.target]!==undefined){a.sendMsg("MODE "+h.info.target);a.sendMsg("NAMES "+h.info.target)}}else{a.state.addUser(h.info.target);a.state.users[h.info.target].mode=h.info.mode;a.state.isModified=true}break;case"NICK":if(a.stricmp(h.prefixNick,a.state.nick)===0){a.state.nick=h.info.nick}a.renameNick(h.info.oldNick,h.info.nick);break;case"QUIT":$.each(a.state.channels,function(j,k){k.removeMember(h.prefixNick)});a.state.removeUser(h.prefixNick);break;case"001":if(!a.state.isRegistered){a.state.isRegistered=true;a.state.isModified=true}break;case"324":if(a.state.channels[h.info.channel]!==undefined){a.state.channels[h.info.channel].mode=h.info.mode;a.state.isModified=true}break;case"331":if(a.state.channels[h.info.channel]!==undefined){a.state.channels[h.info.channel].topic=undefined;a.state.isModified=true}break;case"332":if(a.state.channels[h.info.channel]!==undefined){a.state.channels[h.info.channel].topic=(h.info.topic!=="")?h.info.topic:undefined;a.state.isModified=true}break;case"333":if(a.state.channels[h.info.channel]!==undefined){a.state.channels[h.info.channel].topicSetByNick=h.info.nick;a.state.channels[h.info.channel].topicSetTime=h.info.time;a.state.isModified=true}break;case"403":a.state.removeChannel(h.info.channel);break;case"353":var g=a.state.addChannel(h.info.channel);g.visibility=h.info.visibility;if(g.lastRPL_NAMREPLY<g.lastRPL_ENDOFNAMES){g.clearMembers()}$.each(h.info.names,function(k,j){a.state.addUser(j.nick);memberDesc=g.addMember(j.nick);memberDesc.mode=j.mode});g.lastRPL_NAMREPLY=a.state.messageCount;a.state.isModified=true;break;case"366":if(a.state.channels[h.info.channel]!==undefined){a.state.channels[h.info.channel].lastRPL_ENDOFNAMES=a.state.messageCount}break;case"433":if(!a.state.isRegistered){if(a.state.registrationAttemptCount<a.options.maxRegistrationAttempts){if(a.state.baseNick===undefined){a.state.baseNick=a.state.nick}a.state.nick=""+a.state.baseNick+"_"+a.state.registrationAttemptCount;a.state.registrationAttemptCount++;a.state.isModified=true;$(d).trigger("localMessage.chatmore",[null,"clientMsg",{code:"R1"}]);a.sendMsg("NICK "+a.state.nick)}else{$(d).trigger("localMessage.chatmore",[null,"error",{code:"RE1",maxRegistrationAttempts:a.options.maxRegistrationAttempts}])}}break}break;case"servermsg":if(window.console){if(h.message!==undefined){console.log("servermsg: "+h.code+" "+h.message)}else{console.log("servermsg: "+h.code)}}if(h.code>=400){if(a.state.isActivated&&h.code===400){a.deactivateClient()}}break}$(d).trigger("processedMessage.chatmore",[h]);if(a.state.isModified){$(d).trigger("stateChanged.chatmore");a.state.isModified=false}})}};a.options=$.extend({maxRegistrationAttempts:3,maxResendAttempts:4,pollIntervalDelayMs:100},b);a.state=new chatmoreState();a.state.server=b.server;a.state.port=b.port;a.state.nick=b.nick;a.state.realname=b.realname;a.state.isModified=true;a.target=function(e){if(e===undefined){return c.target}else{if(e===null){e=undefined}c.target=e}};a.activateClient=function(){a.state.isActivated=false;a.state.lastRecvTime=undefined;$(d).trigger("activatingClient.chatmore",["start",undefined,{server:a.state.server,port:a.state.port}]);var h=true;var g=false;var f=function(i){$(d).trigger("activatingClient.chatmore",["error",i,{server:a.state.server,port:a.state.port}])};var e=function(k,i,j){f("Error during activation: "+i+", "+j);g=true};$.ajax("init.php",{async:false,type:"POST",cache:false,dataType:"json",data:{connect:0,viewKey:b.viewKey,server:a.state.server,port:a.state.port},success:function(i){try{c.processMessages.call(a,i);$.each(i,function(k,l){if(l.type==="servermsg"){if(l.code===200){h=false}else{if(l.code>400){f(l.message);g=true}}}})}catch(j){if(window.console){console.error("Exception caught while processing messages:");console.error(i);console.error(j)}}},error:e});if(g){return}if(h){$(d).trigger("activatingClient.chatmore",["connecting",undefined,{server:a.state.server,port:a.state.port}])}else{$(d).trigger("activatingClient.chatmore",["resuming",undefined,{server:a.state.server,port:a.state.port}])}$.ajax("init.php",{type:"POST",cache:false,dataType:"json",data:{connect:1,viewKey:b.viewKey},success:function(j){try{c.processMessages.call(a,j);if($.grep(j,function(l){return l.type==="servermsg"&&l.code===200}).length){$(d).trigger("activatingClient.chatmore",["activated",undefined,{server:a.state.server,port:a.state.port}]);a.state.isActivated=true;if(h){a.register(a.state.nick,a.state.realname)}var i=function(){if(c.pauseRecv){setTimeout(i,100)}else{c.pollHandle=undefined;c.pollXhr=$.ajax("recv.php",{cache:false,data:{viewKey:b.viewKey},dataType:"json",success:function(l){if(typeof(l)==="object"){try{c.processMessages.call(a,l)}catch(m){if(window.console){console.error("Exception caught while processing messages:");console.error(l);console.error(m)}}}else{if(window.console){console.warn("Got invalid data:");console.warn(l)}}},complete:function(){c.pollXhr=undefined;if(a.state.isActivated){c.pollHandle=setTimeout(i,a.options.pollIntervalDelayMs)}}})}};setTimeout(i,0);$(d).trigger("activatedClient.chatmore",[{server:a.state.server,port:a.state.port}])}else{$(d).trigger("activatingClient.chatmore",["error","Error during activation",{server:a.state.server,port:a.state.port}])}}catch(k){if(window.console){console.error("Exception caught while processing messages:");console.error(j);console.error(k)}}},error:e})};a.deactivateClient=function(){if(a.state.isActivated){$(d).trigger("deactivatingClient.chatmore");a.state.isActivated=false;if(c.pollHandle!==undefined){clearTimeout(c.pollHandle)}c.pollHandle=undefined;if(c.pollXhr!==undefined){c.pollXhr.abort()}c.pollXhr=undefined;$(d).trigger("deactivatedClient.chatmore")}};a.sendMsg=function(f,g){var e=function(i){var h=function(){if(i<a.options.maxResendAttempts){if(window.console){console.warn("Resending: "+f)}var j=i>0?3000:100;setTimeout(function(){e(i+1)},j)}};$(d).trigger("sendingMessage.chatmore",[f,i]);$.ajax("send.php",{async:true,type:"POST",dataType:"json",cache:false,data:{viewKey:b.viewKey,msg:f},success:function(j){if(g){g(f)}$(d).trigger("sentMessage.chatmore",[f,i]);if(typeof(j)==="object"){try{c.processMessages.call(a,j)}catch(k){if(window.console){console.error("Exception caught while processing messages:");console.error(j);console.error(k)}}}else{if(window.console){console.warn("Got invalid data:");console.warn(j)}h();return false}},error:function(j,k){$(d).trigger("errorSendingMessage.chatmore",[k,f,i]);h()}})};e(0)};a.register=function(e,f){a.state.nick=e;a.state.ident=Math.floor(Math.random()*100000000);a.state.realname=f;a.state.isRegistered=false;a.state.registrationAttemptCount=1;a.state.isModified=true;if(window.console){console.log('Registering user "'+a.state.nick+'" ('+a.state.realname+') on IRC server "'+a.state.server+":"+a.state.port+'"')}a.sendMsg("USER "+a.state.ident+" 0 * :"+a.state.realname);a.sendMsg("NICK "+a.state.nick)};a.sendChannelMsg=function(f,e){this.sendMsg("PRIVMSG "+f+" :"+e)};a.sendPrivateMsg=function(e,f){this.sendMsg("PRIVMSG "+e+" :"+f)};a.sendChannelAction=function(g,f){var e=String.fromCharCode(1);this.sendMsg("PRIVMSG "+g+" :"+e+"ACTION "+f+e)};a.sendPrivateAction=function(e,g){var f=String.fromCharCode(1);this.sendMsg("PRIVMSG "+e+" :"+f+"ACTION "+g+f)};a.sendChannelNotice=function(f,e){this.sendMsg("NOTICE "+f+" :"+e)};a.sendPrivateNotice=function(e,f){this.sendMsg("NOTICE "+e+" :"+f)};a.renameNick=function(e,f){$.each(a.state.channels,function(g,h){if(h.members[e]!==undefined){h.members[f]=h.members[e];h.removeMember(e)}});a.state.users[f]=a.state.users[e];a.state.removeUser(e);a.state.isModified=true};a.stricmp=function(f,e){return f.toLocaleLowerCase().localeCompare(e.toLocaleLowerCase())};a.isChannel=function(e){return e.match(/^[#&+!][^\s,:\cg]+/)}};//
// Chatmore CLI.
//
(function () {
    //
    // Private static variables.
    //
    // Registry of layout plugin instances.
    var layouts = { };

    var globalMethods = {
        layouts: function () {
            return layouts;
        }
    };

    //
    // Private static functions.
    //
    var isEmpty = function (text) {
        return text === undefined || text === null || text === '';
    };

    //
    // Global chatmore jQuery plugin.
    //
    // Exports methods defined in globalMethods.
    // Usage: $.chatmore('method', [arg], ...);
    $.chatmore = function () {
        var method = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        return globalMethods[method].apply(null, args);
    };
    
    //
    // Object chatmore jQuery plugin.
    //
    $.fn.chatmore = function () {
        // charemoreUI constructor() | constructor({options})
        if (arguments.length === 0 || typeof(arguments[0]) === 'object') {
            // Construct UI widget.
            var userOptions = arguments.length > 0 ? arguments[0] : { };
            
            // Parse options.
            var options = {
                port: 6667,
                title: document.title,
                viewKey: '',
                nick: 'user' + Math.floor(Math.random() * 10000),
                quitMessage: 'Chatmore IRC client',
                reactivateAttempts: 6,
                reactivateDelay: 10,
                layout: undefined                   // Layout name.  Undefined will pick 'default' or first layout in registry.
            };
            $.extend(options, userOptions);
            if (isEmpty(options.realname)) options.realname = options.nick;
            if (typeof(options.channel) === 'object') autoJoinChannels = options.channel;
            else if (!isEmpty(options.channel)) autoJoinChannels.push(options.channel);
                
            var getLayoutPlugin = function () {
                if (options.layout === undefined) {
                    if ('default' in layouts) {
                        return layouts['default'];
                    }
                    else {
                        for (var name in layouts) {
                            if (data.propertyIsEnumerable(prop)) return layouts[name];
                        }
                        
                        if (window.console) console.warn('Error initializing Chatmore:  No layout plugins have been loaded!');
                        return false;
                    }
                }
                else {
                    return layouts[options.layout];
                }
            };
    
            var self = {
                //
                // Private members.
                //
                ircElement: $(this),                // Chatmore parent jQuery element.
                irc: undefined,                     // Chatmore client object.
                options: options,
                autoJoinChannels: [ ],              // Channels provided at startup.
                prevState: undefined,
                enableAutoReactivate: true,
                reactivateAttempts: 0,
                isPendingActivation: false,
                layoutPlugin: getLayoutPlugin(),    // Selected layout plugin instance.
                
                // Client /command definitions.
                cmdDefs: {
                    clear: {
                        helpUsage: 'Usage: /clear',
                        helpText: 'Clear the chat console.',
                        parseParam: function () { },
                        exec: function (meta) {
                            self.ircElement.find('.ircConsole .content').html('');
                        }
                    },
                    cleartopic: {
                        helpUsage: 'Usage: /cleartopic',
                        helpText: 'Clear the selected channel\'s topic.',
                        parseParam: function (param, meta) {
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to clear the topic.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('TOPIC ' + self.irc.target() + ' :');
                        }
                    },
                    connect: {
                        helpUsage: 'Usage: /connect',
                        helpText: 'Reconnect after disconnection.',
                        parseParam: function () { },
                        exec: function (meta) {
                            if (self.isPendingActivation) {
                                meta.error = 'Error: Cannot reconnect while connection attempt is pending.  Enter /quit to abort connection attempt.';
                                return false;
                            }
                            else if (self.irc.state.isActivated) {
                                meta.error = 'Error: Cannot reconnect while still connected.';
                                return false;
                            }
                            self.irc.activateClient();
                        }
                    },
                    deop: {
                        helpUsage: 'Usage: /deop &lt;nick&gt; [nick ...]',
                        helpText: 'Revoke channel operator status from a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['deop'].helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to revoke operator status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to revoke operator status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('o');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' -' + os + ' ' + nicks);
                        }
                    },
                    devoice: {
                        helpUsage: 'Usage: /devoice &lt;nick&gt; [nick ...]',
                        helpText: 'Revoke channel voice status from a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['devoice'].helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to revoke voice status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to revoke voice status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('v');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' -' + os + ' ' + nicks);
                        }
                    },
                    help: {
                        helpUsage: 'Usage: /help &lt;command&gt;',
                        helpText: [
                            'Show help for client commands.',
                            'Commands:',
                            ' clear - Clear the chat console',
                            ' cleartopic - Clear the channel\'s topic (must be an operator)',
                            ' connect - Reconnect to IRC server',
                            ' join - Join a channel',
                            ' kick - Kick user from channel (must be an operator)',
                            ' leave - Leave a channel',
                            ' list - Get channel listing',
                            ' me - Send an action message',
                            ' motd - Get the server message of the day',
                            ' msg - Send a private message',
                            ' nick - Change your nick',
                            ' notice - Send a notice to a user or channel',
                            ' op/deop - Grant/revoke channel operator status to a user (must be an operator)',
                            ' query - Select a target for messaging',
                            ' quit - Quit IRC session',
                            ' quote - Send raw IRC message',
                            ' time - Get the server time',
                            ' topic - Get or set the channel\'s topic (must be an operator)',
                            ' voice/devoice - Grant/revoke channel voice to a user (must be an operator)',
                            ' who - Get info on a user'
                        ],
                        parseParam: function (param, meta) {
                            if (param === undefined) param = 'help';
                            
                            if (self.cmdDefs[param] === undefined) {
                                meta.error = 'Error: Cannot get help on unknown command "' + param + '".';
                                return false;
                            }
    
                            meta.cmd = param;
                        },
                        exec: function (meta) {
                            var cmdDef = self.cmdDefs[meta.cmd];
                            self.writeTmpl('help', { message: cmdDef.helpUsage });
                            
                            if (typeof(cmdDef.helpText) === 'object')
                                $.each(cmdDef.helpText, function (i, text) {
                                    self.writeTmpl('help', { message: text });
                                });
                            else
                                self.writeTmpl('help', { message: cmdDef.helpText });
                        }
                    },
                    join: {
                        helpUsage: 'Usage: /join &lt;#channel&gt; [key]',
                        helpText: 'Join a channel.  Include a key if the channel requires it to join.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['join'].helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 2);
                            // Normalize channel name if it's missing a prefix.
                            meta.channel = params[0].replace(/^([^#&+!])/, '#$1');
                            if (params[1] !== undefined) meta.key = params[1];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to join a channel.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.joinChannel(meta.channel, meta.key);
                        }
                    },
                    kick: {
                        helpUsage: 'Usage: /kick &gt;nick&lt; [comment]',
                        helpText: 'Kick user from channel.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs['kick'].helpUsage;
                            var m = /^(\S+)(\s+(.+))?/.exec(param);
                            if (m === null) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nick = m[1];
                            meta.comment = m[3];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to kick a user.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.comment !== undefined)
                                self.irc.sendMsg('KICK ' + meta.channel + ' ' + meta.nick + ' :' + meta.comment);
                            else
                                self.irc.sendMsg('KICK ' + meta.channel + ' ' + meta.nick);
                        }
                    },
                    leave: {
                        helpUsage: 'Usage: /leave [#channel] [comment]',
                        helpText: [
                            'Leave a channel.',
                            'If channel omitted, leaves channel currently selected by /query.'
                        ],
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                if (self.irc.target() === undefined) {
                                    meta.error = self.cmdDefs['leave'].helpUsage;
                                    return false;
                                }
                                else {
                                    meta.channel = self.irc.target();
                                }
                            }
                            else {
                                var m = /^(\S+)(\s+(.+))?\s*$/.exec(param);
                                // Normalize channel name if it's missing a prefix.
                                meta.channel = m[1].replace(/^([^#&+!])/, '#$1');
                                if (m[3] !== undefined) meta.comment = m[3];
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to leave a channel.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.comment !== undefined)
                                self.irc.sendMsg('PART ' + meta.channel + ' :' + meta.comment);
                            else
                                self.irc.sendMsg('PART ' + meta.channel);
                        }
                    },
                    list: {
                        helpUsage: 'Usage: /list [#channel [, #channel ...] ] [server]',
                        helpText: 'Get channel listing.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                // No parameters.
                            }
                            else {
                                // Parse form: channels and server.
                                var m = /^([#&+!][^\s,:\cg]+(\s*,\s*[#&+!][^\s,:\cg]+)*)(\s+(\S+))?\s*$/.exec(param);
                                if (m !== null) {
                                    meta.channels = m[1].split(/\s*,\s*/);
                                    
                                    if (m[4] !== undefined) {
                                        meta.server = m[4];
                                    }
                                }
                                else {
                                    // Parse form: server only
                                    m = /^(\S+)\s*$/.exec(param);
                                    if (m !== null) {
                                        meta.server = m[1];
                                    }
                                    else {
                                        // Unable to parse parameters.
                                        meta.error = self.cmdDefs['list'].helpUsage;
                                        return false;
                                    }
                                }
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get the channel listing.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.channels !== undefined) {
                                if (meta.server !== undefined) {
                                    self.irc.sendMsg('LIST ' + meta.channels.join(',') + ' ' + meta.server);
                                }
                                else {
                                    self.irc.sendMsg('LIST ' + meta.channels.join(','));
                                }
                            }
                            else if (meta.server !== undefined) {
                                self.irc.sendMsg('LIST ' + meta.server);
                            }
                            else {
                                self.irc.sendMsg('LIST');
                            }
                        }
                    },
                    me: {
                        helpUsage: 'Usage: /me &lt;message&gt;',
                        helpText: 'Send an action message to currently selected channel or user.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs['msg'].helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.target = self.irc.target();
                            meta.message = param;
                            
                            if (isEmpty(meta.target)) {
                                meta.error = 'Error: Must select a channel or nick to send a message.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send an action message.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelAction(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelAction', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateAction(meta.target, meta.message);
                                self.writeTmpl('outgoingPrivateAction', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    mode: {
                        helpUsage: 'Usage: /mode &lt;nick | #channel&gt; [ &lt;+mode | -mode&gt; [parameters] ]',
                        helpText: [
                            'Get or change user or channel mode.',
                            'Available user modes: http://tools.ietf.org/html/rfc2812#section-3.1.5',
                            'Available channel modes: http://tools.ietf.org/html/rfc2811#section-4'
                        ],
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs['mode'].helpUsage;
                            var m = /^(\S+)(\s+(\S+(\s+\S+)*))?\s*$/.exec(param);
                            if (m === null) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.target = m[1];
                            
                            if (m[3] !== undefined)
                                meta.modes = m[3].split(/\s+/);
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to change mode.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.modes !== undefined)
                                self.irc.sendMsg('MODE ' + meta.target + ' ' + meta.modes.join(' '));
                            else
                                self.irc.sendMsg('MODE ' + meta.target);
                        }
                    },
                    motd: {
                        helpUsage: 'Usage: /motd [server]',
                        helpText: [
                            'Get the server message of the day.',
                            'If server parameter is omitted, query current server.'
                        ],
                        parseParam: function (param, meta) {
                            meta.server = param;
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get server motd.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.server !== undefined && meta.server.length > 0)
                                self.irc.sendMsg('MOTD ' + meta.server);
                            else
                                self.irc.sendMsg('MOTD');
                        }
                    },
                    msg: {
                        helpUsage: 'Usage: /msg &lt;nick|#channel&gt; &lt;message&gt;',
                        helpText: 'Send a private message to a user.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs['msg'].helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            var m = /^(\S+)\s+(.+)$/.exec(param);
                            if (m === null || m.length !== 3) {
                                meta.error = usage;
                                return false;
                            }
                            meta.target = m[1];
                            meta.message = m[2];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a message.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelMsg(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelMsg', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateMsg(meta.target, meta.message);
                                //self.addToMsgSenders(meta.target);
                                self.writeTmpl('outgoingPrivateMsg', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    nick: {
                        helpUsage: 'Usage: /nick &lt;nickname&gt;',
                        helpText: 'Change your nick.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['nick'].helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 1);
                            meta.nick = params[0];
    
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to change your nickname.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('NICK ' + meta.nick);
                        }
                    },
                    notice: {
                        helpUsage: 'Usage: /notice &lt;nick|#channel&gt; &lt;message&gt;',
                        helpText: 'Send a notice to a user or channel.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs['msg'].helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            var m = /^(\S+)\s+(.+)$/.exec(param);
                            if (m === null || m.length !== 3) {
                                meta.error = usage;
                                return false;
                            }
                            meta.target = m[1];
                            meta.message = m[2];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a notice.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelNotice(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelNotice', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateNotice(meta.target, meta.message);
                                self.writeTmpl('outgoingPrivateNotice', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    op: {
                        helpUsage: 'Usage: /op &lt;nick&gt; [nick ...]',
                        helpText: 'Grant channel operator status to a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['op'].helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to grant operator status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to grant operator status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('o');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' +' + os + ' ' + nicks);
                        }
                    },
                    query: {
                        helpUsage: 'Usage: /query &lt;nick|#channel&gt;',
                        helpText: 'Select a user or channel to send messages.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['query'].helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 1);
                            meta.target = params[0];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to query a target.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.queryTarget(meta.target);
                        }
                    },
                    quit: {
                        helpUsage: 'Usage: /quit [comment]',
                        helpText: 'Quit IRC session.',
                        parseParam: function (param, meta) {
                            meta.comment = param;
                        
                            if (!self.irc.state.isActivated && !self.isPendingActivation) {
                                meta.error = 'Error: Must be connected to quit.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.irc.target() !== undefined) self.queryTarget(undefined);
                            
                            var comment = meta.comment !== undefined ? meta.comment : self.options.quitMessage;
                            self.enableAutoReactivate = false;
                            if (self.isPendingActivation) {
                                self.isPendingActivation = false;
                                self.writeTmpl('error', { message: 'Server connection aborted.' });
                            }
                            else {
                                self.irc.sendMsg('QUIT :' + comment);
                            }
                        }
                    },
                    quote: {
                        helpUsage: 'Usage: /quote &gt;IRC request message&lt;',
                        helpText: 'Send a raw IRC request based on RFC2812.',
                        parseParam: function (param, meta) {
                            meta.param = param;
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a raw IRC request.';
                                return false;
                            }
                            
                            if (isEmpty(meta.param)) {
                                meta.error = 'Missing parameter to /quote.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg(meta.param);
                        }
                    },
                    time: {
                        helpUsage: 'Usage: /time [server]',
                        helpText: [
                            'Get the server time.',
                            'If server parameter is omitted, query current server.'
                        ],
                        parseParam: function (param, meta) {
                            meta.server = param;
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get server time.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.server !== undefined && meta.server.length > 0)
                                self.irc.sendMsg('TIME ' + meta.server);
                            else
                                self.irc.sendMsg('TIME');
                        }
                    },
                    topic: {
                        helpUsage: 'Usage: /topic [message]',
                        helpText: 'Get or set the selected channel\'s topic',
                        parseParam: function (param, meta) {
                            meta.topic = param;

                            if (self.irc.target() === undefined) {
                                meta.error = 'Error: No target selected.  Doubleclick a channel or user on the side bar or enter: /query &lt;nick|#channel&gt;.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get or set the topic.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.topic === undefined) {
                                self.irc.sendMsg('TOPIC ' + self.irc.target());
                            }
                            else {
                                self.irc.sendMsg('TOPIC ' + self.irc.target() + ' :' + meta.topic);
                            }
                        }
                    },
                    voice: {
                        helpUsage: 'Usage: /voice &lt;nick&gt; [nick ...]',
                        helpText: 'Grant channel voice status to a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs['voice'].helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to grant voice status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to grant voice status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('v');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' +' + os + ' ' + nicks);
                        }
                    },
                    who: {
                        helpUsage: 'Usage: /who &lt;nick | channel&gt;',
                        helpText: 'Get info on a user or all users in a channel.',
                        parseParam: function (param, meta) {
                            meta.target = param;

                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get WHO information.';
                                return false;
                            }
                            
                            if (isEmpty(meta.target)) {
                                meta.error = 'Missing parameter to /quote.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('WHO ' + meta.target);
                        }
                    }
                },
    
                // Send line from user entry.
                // Parse out client commands and execute action.
                // If not a command, send as message to current target.
                sendLine: function (text) {
                    // Parse out command and parameters.
                    var m = /^\/(\S+)(\s+(.+))?/.exec(text);
                    if (m) {
                        var cmd = m[1].toLowerCase();
                        var param = m[3];
                        
                        if (self.cmdDefs[cmd] === undefined) {
                            self.writeTmpl('error', { message: 'Error: Unknown client command "' + cmd + '".' });
                        }
                        else {
                            var meta = {};
                            var cmdDef = self.cmdDefs[cmd];
                            if (cmdDef.parseParam && cmdDef.parseParam(param, meta) === false) {
                                if (meta.error) self.writeTmpl('error', { message: meta.error });
                            }
                            else {
                                cmdDef.exec(meta);
                            }
                        }
                    }
                    // Send text to selected target.
                    else if (self.irc.state.isActivated) {
                        // Sanitize input.
                        if (self.irc.target() !== undefined) {
                            text = text.replace(/([\n\r])/gm, '');
                            if (text.length > 0) {
                                self.sendLine('/msg ' + self.irc.target() + ' ' + text);
                            }
                        }
                        else {
                            self.writeTmpl('error', { message: 'Error: No target selected.  Use: /query <nick|#channel> or /join <#channel>.' });
                        }
                    }
                    else {
                        self.writeTmpl('error', { message: 'Error: Cannot send message, client not activated.' });
                    }
                },
    
                getShortTimestamp: function () {
                    var d = new Date();
                    return d.getHours() + ':' + self.padZero(d.getMinutes(), 2);
                },
    
                getLongTimestamp: function () {
                    return new Date().toLocaleString();
                },
                
                padZero: function (n, digits) {
                    var z = new Array(digits + 1).join('0');
                    var pn = '' + z + n;
                    return pn.substring(pn.length - digits);
                },
    
                formatTime: function(time) {
                    var d = new Date();
                    d.setTime(time * 1000);
                    return d.toLocaleString();
                },
                
                isChannel: function (target) {
                    return target.match(/^[#&+!][^\s,:\cg]+/);
                },
    
                stricmp: function (a, b) {
                    return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase());
                },
                
                writeTmpl: function(templateName, data) {
                    self.layoutPlugin.writeTemplate(self, templateName, data);
                },
                
                startsWith: function (subject, prefix, comparer) {
                    return subject.length >= prefix.length &&
                        comparer(subject.substr(0, prefix.length), prefix) === 0;
                },
    
                // Find next match from a list, where the item is greater than seed.
                // comparer is function(a, b) returning -1, 0, or 1.
                getNextMatch: function (list, seed, comparer) {
                    if (list.length > 0) {
                        if (seed === undefined || seed === null)
                            return list[0];
                            
                        // Find next match.
                        for (var i in list) {
                            var val = list[i];
                            if (comparer(val, seed) > 0) {
                                return val;
                            }
                        }
                        
                        // Wrap around to beginning of list.
                        return list[0];
                    }
                    else {
                        return undefined;
                    }
                },
                
                clearSelection: function () {
                    if (window.getSelection) {
                        window.getSelection().removeAllRanges();
                    }
                    else if (document.selection) {
                        document.selection.empty();
                    }
                },
    
                joinChannel: function (channel, key) {
                    if (self.irc.state.channels[channel] !== undefined) {
                        // If already joined to this channel, just query it.
                        self.queryTarget(channel);
                    }
                    else {
                        if (key !== undefined)
                            self.irc.sendMsg('JOIN ' + channel + ' ' + key);
                        else
                            self.irc.sendMsg('JOIN ' + channel);
                    }
                },
    
                queryTarget: function (target) {
                    if (window.console) console.log('queryTarget(' + target + ')');
                    var prevTarget = self.irc.target();
                    
                    if (target !== prevTarget) {
                        self.irc.target(target);
    
                        self.writeTmpl(target === undefined ? 'queryOff' : 'query', {
                            target: target,
                            prevTarget: prevTarget
                        });
    
                        // Update user mode line.
                        self.ircElement.find('.targetFragment').fadeOut(null, function () {
                            self.ircElement.find('.targetLabel').text(target);
                            if (target !== undefined && target !== null) {
                                var isChannel = self.isChannel(target);
                                self.ircElement.find('.targetLabel')
                                    .removeClass(isChannel ? 'nick' : 'channel')
                                    .addClass(isChannel ? 'channel' : 'nick');
        
                                self.ircElement.find('.targetFragment').fadeIn();
                            }
                        });
                    }
                },
                
                // Handle renaming of a nick of any user.
                getJoinedChannels: function () {
                    var channels = [ ];
                    
                    if (self.irc.state !== undefined) {
                        channels = $.map(self.irc.state.channels, function (val, channel) {
                            return channel;
                        });
                    }
    
                    return channels.sort(self.stricmp);
                },
                
                getChannelMembers: function (channel) {
                    var members = [ ];
                    
                    if (self.irc.state !== undefined) {
                        var channelDesc = self.irc.state.channels[channel];
                        
                        if (channelDesc !== undefined) {
                            members = $.map(channelDesc.members, function (val, member) {
                                return member;
                            });
                        }
                    }
                    
                    return members.sort(self.stricmp);
                },
    
                // Get length of an object array.
                // Based on: http://stackoverflow.com/questions/5223/length-of-javascript-associative-array
                getLength: function (obj) {
                    if (obj.length) {
                        // Non-object array.
                        return obj.length;
                    }
                    else if (Object.keys) {
                        // Object
                        return Object.keys(obj).length;
                    }
                    else {
                        // Object.  Manually counting elements.
                        var size = 0;
                        
                        for (var key in obj) {
                            if (obj.hasOwnProperty(key)) size++;
                        }
                        
                        return size;
                    }
                },
                
                // Clone an object or array structure.  Does not preserve prototype.
                // Based on: http://my.opera.com/GreyWyvern/blog/show.dml/1725165
                clone: function(obj) {
                    var newObj = (obj instanceof Array) ? [] : {};
                    for (key in obj) {
                        newObj[key] = (obj[key] && typeof obj[key] === "object") ? self.clone(obj[key]) : obj[key];
                    }
                    return newObj;
                },
                
                //
                // Public API.
                //
                methods: {
                    // Activate client.
                    activateClient: function () {
                        self.irc.activateClient();
                        return self.ircElement;
                    },
                    // Deactivate client.
                    deactivateClient: function () {
                        self.irc.deactivateClient();
                        return self.ircElement;
                    },
                    // Resize chatmoreUI element.
                    // Omit width/height to resize to fit.
                    resize: function (width, height) {
                        self.layoutPlugin.resize(self, width, height);
                        return self.ircElement;
                    },
                    // Scroll console to bottom.
                    scrollToBottom: function () {
                        self.layoutPlugin.scrollToBottom(self);
                        return self.ircElement;
                    },
                    //
                    // Property getters.
                    //
                    // Determine if console is scrolled to the bottom.
                    isAtBottom: function () {
                        return self.layoutPlugin.isAtBottom(self);
                    },
                    //
                    // Customization API.
                    //
                    // Get layout registry hash.
                    layouts: function () {
                        return layouts;
                    },
                    // Set and initialize a layout plugin.
                    setLayout: function (name) {
                        if (name in layouts) {
                            // Clean up previous layout plugin.
                            if (self.layoutPlugin !== undefined) self.layoutPlugin.destroy(self);
                            
                            // Initialize new layout plugin.
                            self.layoutPlugin = layouts[name];
                            self.layoutPlugin.initialize(self);
                        }
                        else if (window.console) {
                            console.warn('Attempted to use Chatmore layout that does not exist: ' + name);
                        }
                    },
                    //
                    // Event binding methods.
                    //
                    // Bind event 'localMessage'.  Signature: callback(e, msg)
                    onLocalMessage: function (callback) {
                        self.ircElement.on('localMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'stateChanged'.  Signature: callback(e, state)
                    onStateChanged: function (callback) {
                        self.ircElement.on('stateChanged.chatmore', function (e) {
                            callback.call(self.ircElement, e, self.irc.state);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'processingMessage'.  Signature: callback(e, msg)
                    onProcessingMessage: function (callback) {
                        self.ircElement.on('processingMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'processedMessage'.  Signature: callback(e, msg)
                    onProcessedMessage: function (callback) {
                        self.ircElement.on('processedMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'sendingMessage'.  Signature: callback(e, rawMsg, resendCount)
                    onSendingMessage: function (callback) {
                        self.ircElement.on('sendingMessage.chatmore', function (e, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'sentMessage'.  Signature: callback(e, rawMsg, resendCount)
                    onSentMessage: function (callback) {
                        self.ircElement.on('sentMessage.chatmore', function (e, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'errorSendingMessage'.  Signature: callback(e, xhr, rawMsg, resendCount)
                    onErrorSendingMessage: function (callback) {
                        self.ircElement.on('errorSendingMessage.chatmore', function (e, xhr, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, xhr, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'activatingClient'.  Signature: callback(e, stage, message, params)
                    onActivatingClient: function (callback) {
                        self.ircElement.on('activatingClient.chatmore', function (e, stage, message, params) {
                            callback.call(self.ircElement, e, stage, message, params);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'deactivatingClient'.  Signature: callback(e)
                    onDeactivatingClient: function (callback) {
                        self.ircElement.on('deactivatingClient.chatmore', function (e) {
                            callback.call(self.ircElement, e);
                        });
                        return self.ircElement;
                    }
                }
            };
    
            //
            // Initialization.
            //
            // Setup layout.
            self.ircElement
                .empty()
                .off()
                .data('chatmore', self); // Persist object in DOM element.
    
            self.layoutPlugin.initialize(self);
    
            // Client command aliases.
            self.cmdDefs['j'] = self.cmdDefs['join'];
            self.cmdDefs['k'] = self.cmdDefs['kick'];
            self.cmdDefs['l'] = self.cmdDefs['leave'];
            self.cmdDefs['m'] = self.cmdDefs['msg'];
            self.cmdDefs['n'] = self.cmdDefs['notice'];
            self.cmdDefs['q'] = self.cmdDefs['query'];
    
            // Setup chatmore event handlers.
            self.ircElement
                .on('localMessage.chatmore', function (e, message, type, data) {
                    if (window.console) console.log('UI event: localMessage');
                    switch (data.code) {
                    case 'R1':
                        // Retrying registration with new nick.
                        self.writeTmpl('retryRegistration', {});
                        break;
                        
                    case 'RE1':
                        // Registration failed.  Abort activation.
                        var m = data.maxRegistrationAttempts > 1 ?
                            'Registration failed.  Unable to register with a unique nickname after ' + data.maxRegistrationAttempts + ' attempts.  Please reconnect with a unique nickname.' :
                            'Registration failed.  Please reconnect with a unique nickname.';
                        self.writeTmpl(type, { message: m });
                            
                        self.enableAutoReactivate = false;
                        self.irc.deactivateClient();
                        break;
                    
                    default:
                        self.writeTmpl(type, { message: message });
                    }
                    
                    self.layoutPlugin.onLocalMessage(self, message, type, data);
                })
                .on('processingMessage.chatmore', function (e, msg) {
                    if (msg.type === 'recv') {
                        // Ensure user is in user state.
                        self.irc.state.addUser(msg.prefixNick);
    
                        // ERR_NICKNAMEINUSE
                        if (msg.command === '433') {
                            self.writeTmpl('nickInUse', { msg: msg });
                        }
                    }
                    
                    self.layoutPlugin.onProcessingMessage(self, msg);
                })
                .on('processedMessage.chatmore', function (e, msg) {
                    if (msg.type === 'recv') {
                        switch (msg.command) {
                        case 'PRIVMSG':
                            if (self.stricmp(msg.info.target, self.irc.state.nick) === 0)
                                self.writeTmpl(msg.info.isAction ? 'incomingPrivateAction' : 'incomingPrivateMsg', { msg: msg });
                            else
                                self.writeTmpl(msg.info.isAction ? 'incomingChannelAction' : 'incomingChannelMsg', { msg: msg });
                            break;
                        
                        case 'NOTICE':
                            if (self.stricmp(msg.info.target, self.irc.state.nick) === 0)
                                self.writeTmpl('incomingPrivateNotice', { msg: msg });
                            else
                                self.writeTmpl('incomingChannelNotice', { msg: msg });
                            break;
                            
                        case 'JOIN':
                            self.writeTmpl('join', { msg: msg });
    
                            // Auto-query newly joined channel.
                            if (self.stricmp(msg.prefixNick, self.irc.state.nick) === 0) {
                                self.queryTarget(msg.info.channel);
                            }
    
                            break;
                            
                        case 'PART':
                            self.writeTmpl('leave', { msg: msg });                        
                            break;
                            
                        case 'KICK':
                            var kickMsg = $.extend(true, { }, msg);
                            delete kickMsg.info.kicks;
                            $.each(msg.info.kicks, function (i, kick) {
                                kickMsg.info.kick = kick;
                                self.writeTmpl('kick', { msg: kickMsg });
                            });
                            break;
                            
                        case 'MODE':
                            self.writeTmpl('mode', { msg: msg });
                            break;
                        
                        case 'NICK':
                            self.writeTmpl('nick', { msg: msg });
                                                    
                            // If selected target's nick changes, update target.
                            if (self.irc.target() !== undefined && self.stricmp(msg.prefixNick, self.irc.target()) === 0) {
                                self.queryTarget(msg.info.nick);
                            }
                            break;
                            
                        case 'TOPIC':
                            self.writeTmpl('changeTopic', { msg: msg });
                            break;
                            
                        case 'QUIT':
                            self.writeTmpl('quit', { msg: msg });
                            break;
                            
                        case 'ERROR':
                            self.writeTmpl('error', {
                                message: msg.info.message
                            });
                            break;
    
                        case '001': // Welcome
                            // Auto-join channels.
                            if (self.autoJoinChannels !== undefined && self.autoJoinChannels.length > 0) {
                                $.each(self.autoJoinChannels.sort(self.stricmp).reverse(), function (idx, channel) {
                                    if (window.console) console.log('Joining channel: ' + channel);
                                    self.irc.sendMsg('JOIN ' + channel);
                                });
                            }
                            break;
                            
                        case '252': // RPL_LUSEROP
                        case '253': // RPL_LUSERUNKNOWN
                        case '254': // RPL_LUSERCHANNELS
                            self.writeTmpl('serverMsg', {
                                number: msg.info.number,
                                message: msg.info.message
                            });
                            break;
                            
                        case '322': // RPL_LIST
                            self.writeTmpl('list', { msg: msg });
                            break;
                            
                        case '331': // RPL_NOTOPIC
                            self.writeTmpl('notopic', { msg: msg });
                            break;
                            
                        case '332': // RPL_TOPIC
                            self.writeTmpl('topic', { msg: msg });
                            break;
                            
                        case '333': // Topic set by
                            self.writeTmpl('topicSetBy', { msg: msg });
                            break;
                            
                        case '352': // RPL_WHOREPLY
                            self.writeTmpl('who', { msg: msg });
                            break;
                            
                        case '391': // RPL_TIME
                            self.writeTmpl('serverTime', { msg: msg });
                            break;
                            
                        case '403': // ERR_NOSUCHCHANNEL
                            self.writeTmpl('serverMsg', { message: msg.info.message });
                            break;
                            
                        case '477': // ERR_NOCHANMODES
                            self.writeTmpl('serverMsg', {
                                channel: msg.info.channel,
                                message: msg.info.message
                            });
                            break;
    
                        // Disregard these messages.
                        case '004': // RPL_MYINFO
                        case '005': // RPL_BOUNCE
                        case '323': // RPL_LISTEND
                        case '324': // RPL_CHANNELMODEIS
                        case '353': // RPL_NAMREPLY
                        case '366': // RPL_ENDOFNAMES
                        case '433': // ERR_NICKNAMEINUSE (handled in processingMessage)
                            break;
                            
                        default:
                            // Any other server message.
                            if (msg.info.message !== undefined) {
                                self.writeTmpl('serverMsg', { message: msg.info.message });
                            }
                            break;
                        }
                    }
                    
                    self.layoutPlugin.onProcessedMessage(self, msg);
                })
                .on('stateChanged.chatmore', function (e) {
                    if (window.console) console.log('UI event: stateChanged');
                    if (window.console) console.log(self.irc.state);
                    
                    var state = self.irc.state;
                    
                    if (self.prevState === undefined || self.stricmp(state.nick, self.prevState.nick) !== 0) {
                        // Nick changed.
                        if (window.console) console.log('Nick changed.');
                        var nickLabel = self.ircElement.find('.nickLabel');
                        nickLabel.fadeOut(null, function () {
                            nickLabel.text(state.nick);
                            nickLabel.fadeIn();
                        });
                    }
    
                    // Auto-query first channel if selected user/channel is no longer available.
                    var target = self.irc.target();
                    if (target !== undefined) {
                        var isChannel = self.isChannel(target);
                        if (isChannel && !(target in state.channels)) {
                            var channel = self.getJoinedChannels()[0];
                            if (window.console) console.log('Selected channel is no longer joined.  Selecting first channel: ' + channel);
                            self.queryTarget(channel);
                        }
                        else if (!isChannel && !(target in state.users)) {
                            var channel = self.getJoinedChannels()[0];
                            if (window.console) console.log('Selected user is no longer available.  Selecting first channel: ' + channel);
                            self.queryTarget(channel);
                        }
                    }
                    
                    self.layoutPlugin.onStateChanged(self);
                    
                    self.prevState = self.clone(self.irc.state);
                })
                .on('sendingMessage.chatmore', function (e, rawMsg, resendCount) {
                    self.layoutPlugin.onSendingMessage(self, rawMsg, resendCount);
                })
                .on('errorSendingMessage.chatmore', function (e, xhr, rawMsg, resendCount) {
                    if (window.console) {
                        console.warn('Error sending message: ' + rawMsg + ', resendCount: ' + resendCount);
                        console.warn(xhr);
                    }
                    self.layoutPlugin.onErrorSendingMessage(self, xhr, rawMsg, resendCount);

                    if (resendCount == self.irc.options.maxResendAttempts) {
                        // Give user error that a message could not be sent after max attempts.
                        self.writeTmpl('error', { message: 'Unable to send message: ' + rawMsg });
                    }
                    else if (resendCount == 2) {
                        // Give user warning that a message could not be sent after a second attempt.
                        self.writeTmpl('error', { message: 'Error sending message to server, will try again: ' + rawMsg });
                    }
                })
                .on('activatingClient.chatmore', function (e, stage, message, params) {
                    switch (stage) {
                    case 'start':
                        if (window.console) console.log('UI event: activatingClient start');
                        self.isPendingActivation = true;
                        self.ircElement.find('.userEntry').focus();
                        break;
                        
                    case 'connecting':
                        if (window.console) console.log('UI event: activatingClient connecting');
                        var server = params.server + (params.port != 6667 ? (':' + params.port) : '');
                        self.writeTmpl('clientMsg', { message: 'Connecting to IRC server ' + server });
                        break;
                        
                    case 'resuming':
                        if (window.console) console.log('UI event: activatingClient resuming');
                        var server = params.server + (params.port != 6667 ? (':' + params.port) : '');
                        self.writeTmpl('clientMsg', { message: 'Resuming existing IRC connection to ' + server });
    
                        // Auto-join channels.
                        var channels = self.autoJoinChannels.sort(self.stricmp);
                        if (channels.length > 0) {
                            $.each(channels, function (idx, channel) {
                                if (window.console) console.log('Rejoining channel: ' + channel);
                                self.irc.sendMsg('JOIN ' + channel);
                                self.irc.sendMsg('NAMES ' + channel);
                            });
    
                            // Auto-query first channel.
                            self.queryTarget(channels[0]);
                        }
                        break;
                        
                    case 'activated':
                        if (window.console) console.log('UI event: activatingClient activated');
                        self.ircElement
                            .removeClass('deactivated')
                            .addClass('activated');
                        self.reactivateAttempts = 0;
                        self.enableAutoReactivate = true;
                        self.isPendingActivation = false;
                        break;
    
                    case 'error':
                        if (window.console) console.log('UI event: activatingClient error');
                        self.isPendingActivation = false;
                        self.writeTmpl('error', { message: message });
                        break;
                    }
                    
                    self.layoutPlugin.onActivatingClient(self, stage, message, params);
                })
                .on('deactivatingClient.chatmore', function () {
                    if (window.console) console.log('UI event: deactivatingClient');
                    self.ircElement
                        .removeClass('activated')
                        .addClass('deactivated');
                    
                    if (self.enableAutoReactivate) {
                        // Attempt reactivation.
                        if (self.reactivateAttempts < self.options.reactivateAttempts) {
                            //self.freezeSideBar = true;
                            self.isPendingActivation = true;
                            self.writeTmpl('error', { message: 'Server connection lost.  Retrying connection in ' + self.options.reactivateDelay + ' seconds...  Enter /quit to abort.' });
    
                            setTimeout(function () {
                                if (self.enableAutoReactivate) {
                                    self.reactivateAttempts++;
                                    self.irc.activateClient();
                                }
                            }, self.options.reactivateDelay * 1000);
                        }
                        else {
                            self.isPendingActivation = false;
                            self.writeTmpl('error', { message: 'Server connection lost and will not reconnect.  Sorry about that.' });
                            //self.freezeSideBar = false;
                        }
                    }
                    else {
                        self.isPendingActivation = false;
                        self.writeTmpl('error', { message: 'Server connection closed.' });
                        //self.freezeSideBar = false;
                    }
                    
                    self.layoutPlugin.onDeactivatingClient(self);
                });
                
            // Setup user event handlers.
            $.each([ 'onStateChanged', 'onLocalMessage', 'onProcessingMessage', 'onProcessedMessage', 'onSendingMessage',
                'onErrorSendingMessage', 'onSentMessage', 'onActivatingClient', 'onDeactivatingClient' ],
                function (idx, event) {
                    if (event in options) {
                        self.ircElement.chatmore(event, options[event]);
                    }
                }
            );
                        
            // Create chatmore client.
            self.irc = new chatmore(self.ircElement[0], options);
            if (options.activateImmediately) self.irc.activateClient();
            
            return self.ircElement;
        }
        else {
            // Invoke named method against chatmoreUI object.
            var method = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            var self = $(this).data('chatmore');
            return self.methods[method].apply(self, args);
        }
    };
})();
// Default layout plugin for Chatmore.
(function () {
    //
    // Private static variables.
    //
    var layout;
    
    // IRC client message templates.
    var templates = {
        title: '<span>{{if messageCount == 1}}A new message has arrived! -- ' +
            '{{else messageCount > 1}}${messageCount} new messages have arrived! -- ' +
            '{{/if}}' +
            '${self.options.title} - ${self.irc.state.server}:${self.irc.state.port}</span>',
        timestamp: '<span class="timestamp" title="${self.getLongTimestamp()}">[${self.getShortTimestamp()}]&nbsp;</span>',
        bullet: '&bull;&bull;&bull;',
        notePrefix: '<span class="prefix">{{tmpl "bullet"}}</span>',
        error: '{{tmpl "timestamp"}}<span class="error">' +
            '{{tmpl "notePrefix"}} <span class="message">${message}</span>' +
            '</span>',
        usage: '{{tmpl "timestamp"}}<span class="usage">' +
            '{{tmpl "notePrefix"}} <span class="message">${message}</span>' +
            '</span>',
        help: '{{tmpl "timestamp"}}<span class="help">' +
            '{{tmpl "notePrefix"}} <span class="message">${message}</span>' +
            '</span>',
        serverMsg: '{{tmpl "timestamp"}}<span class="serverMsg">' +
            '{{tmpl "notePrefix"}} ' +
            '{{if channel}}&lt;<span class="channel">${channel}</span>&gt; {{/if}}' +
            '<span class="message">' +
            '{{if number}}${number} {{/if}}' +
            '${message}</span>' +
            '</span>',
        clientMsg: '{{tmpl "timestamp"}}<span class="clientMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">${message}</span>' +
            '</span>',
        outgoingChannelMsg: '{{tmpl "timestamp"}}<span class="channelMsg">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>&gt;</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        outgoingChannelAction: '{{tmpl "timestamp"}}<span class="channelMsg action">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>&gt; &bull; <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        outgoingChannelNotice: '{{tmpl "timestamp"}}<span class="channelNotice outgoing">' +
            '<span class="prefix">-<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        outgoingPrivateMsg: '{{tmpl "timestamp"}}<span class="privateMsg outgoing">' +
            '<span class="prefix">&bull;<span class="nick">${msg.info.target}</span>&bull;</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        outgoingPrivateAction: '{{tmpl "timestamp"}}<span class="privateMsg outgoing action">' +
            '<span class="prefix">&bull;<span class="nick">${msg.info.target}</span>&bull; <span class="nick">${msg.prefixNick}</span></span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        outgoingPrivateNotice: '{{tmpl "timestamp"}}<span class="privateNotice outgoing">' +
            '<span class="prefix">-<span class="nick">${msg.info.target}</span>-</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingChannelMsg: '{{tmpl "timestamp"}}<span class="channelMsg">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>&gt;</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingChannelAction: '{{tmpl "timestamp"}}<span class="channelMsg action">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>&gt; &bull; <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingChannelNotice: '{{tmpl "timestamp"}}<span class="channelNotice incoming">' +
            '<span class="prefix">-<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingPrivateMsg: '{{tmpl "timestamp"}}<span class="privateMsg incoming">' +
            '<span class="prefix">&bull;<span class="nick">${msg.prefixNick}</span>&bull;</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingPrivateAction: '{{tmpl "timestamp"}}<span class="privateMsg incoming action">' +
            '<span class="prefix">&bull; <span class="nick">${msg.prefixNick}</span></span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        incomingPrivateNotice: '{{tmpl "timestamp"}}<span class="privateNotice incoming">' +
            '<span class="prefix">-<span class="nick">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${msg.info.text}</span>' +
            '</span>',
        queryOff: '{{tmpl "timestamp"}}<span class="queryMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.isChannel(prevTarget)}}' +
                'You are no longer talking on channel <span class="channel">${prevTarget}</span>' +
            '{{else}}' +
                'Ending conversation with <span class="nick">${prevTarget}</span>' +
            '{{/if}}' +
            '</span></span>',
        query: '{{tmpl "timestamp"}}<span class="queryMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.isChannel(target)}}' +
                'You are now talking on channel <span class="channel">${target}</span>' +
            '{{else}}' +
                'Starting conversation with <span class="nick">${target}</span>' +
            '{{/if}}' +
            '</span></span>',
        join: '{{tmpl "timestamp"}}<span class="JOIN">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> (${msg.prefixUser}@${msg.prefixHost}) has joined the channel</span>' +
            '</span>',
        leave: '{{tmpl "timestamp"}}<span class="PART">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> has left the channel{{if !!msg.info.comment}}: ${msg.info.comment}{{/if}}</span>' +
            '</span>',
        kick: '{{tmpl "timestamp"}}<span class="KICK">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.kick.channel}</span>&gt;</span> ' +
            '<span class="message">' +
            '{{if self.stricmp(self.irc.state.nick, msg.info.kick.nick) === 0}}' +
                'You have been kicked from the channel by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.kick.channel)}">${msg.prefixNick}</span>' +
            '{{else}}' +
                '<span class="nick ${layout.getColorizeCSSClass(self, msg.info.kick.nick, msg.info.kick.channel)}">${msg.info.kick.nick}</span> has been kicked from the channel by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.kick.channel)}">${msg.prefixNick}</span>' +
            '{{/if}}' +
            '{{if msg.info.comment !== undefined && msg.info.comment !== msg.prefixNick}}: ${msg.info.comment}{{/if}}</span>' +
            '</span>',
        nick: '{{tmpl "timestamp"}}<span class="NICK">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.stricmp(self.irc.state.nick, msg.prefixNick) === 0}}' +
                'Nick changed to <span class="nick">${msg.info.nick}</span>' +
            '{{else}}' +
                '<span class="nick">${msg.prefixNick}</span> is now known as <span class="nick">${msg.info.nick}</span>' +
            '{{/if}}' +
            '</span></span>',
        nickInUse: '{{tmpl "timestamp"}}<span class="serverMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">Nickname <span class="nick">${msg.info.nick}</span> is already in use.</span>' +
            '</span>',
        notopic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message no-decorate">No topic is set</span>' +
            '</span>',
        topic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message">' +
            '{{if msg.info.topic !== undefined}}' +
                '<span class="no-decorate">The current topic is:</span> <span class="topicMessage">${msg.info.topic}</span>' +
            '{{else}}' +
                '<span class="message no-decorate">No topic is set</span>' +
            '{{/if}}' +
            '</span>' +
            '</span>',
        changeTopic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="no-decorate"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> ' +
            '{{if msg.info.topic == ""}}' +
                'has cleared the topic</span>' +
            '{{else}}' +
                'has changed the topic to: </span><span class="topicMessage">${msg.info.topic}</span>' +
            '{{/if}}' +
            '</span></span>',
        topicSetBy: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message no-decorate">Topic set by <span class="nick ${layout.getColorizeCSSClass(self, msg.info.nick, msg.info.channel)}">${msg.info.nick}</span> on <span class="time">${self.formatTime(msg.info.time)}</span></span>' +
            '</span>',
        who: '{{tmpl "timestamp"}}<span class="WHO">' +
            '{{tmpl "notePrefix"}} <span class="message">WHO for <span class="nick ${layout.getColorizeCSSClass(self, msg.info.nick, msg.info.channel)}">${msg.info.nick}</span>: "${msg.info.realname}" ${msg.info.user}@${msg.info.host} on server ${msg.info.server}' +
            '</span>',
        serverTime: '{{tmpl "timestamp"}}<span class="TIME">' +
            '{{tmpl "notePrefix"}} <span class="message">Server time for <span class="server">${msg.info.server}</span>: <span class="time">${msg.info.timeString}</span></span>' +
            '</span>',
        quit: '{{tmpl "timestamp"}}<span class="QUIT">' +
            '{{tmpl "notePrefix"}} <span class="message">Signoff: <span class="nick">${msg.prefixNick}</span> (${msg.info.message})</span>' +
            '</span>',
        error: '{{tmpl "timestamp"}}<span class="ERROR">' +
            '{{tmpl "notePrefix"}} <span class="message">${message}</span>' +
            '</span>',
        mode: '{{tmpl "timestamp"}}<span class="MODE">' +
            '{{tmpl "notePrefix"}} <span class="message">Mode change "<span class="modeString">${msg.info.mode}</span>" for ' +
            '{{if self.isChannel(msg.info.target)}}' +
                'channel <span class="channel">${msg.info.target}</span> ' +
                'by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span>' +
            '{{else}}'  +
                'user <span class="nick">${msg.info.target}</span> ' +
                'by <span class="nick">${msg.prefixNick}</span></span>' +
            '{{/if}}' +
            '</span>',
        list: '{{tmpl "timestamp"}}<span class="LIST">' +
            '{{tmpl "notePrefix"}} <span class="message"><span class="no-decorate"><span class="channel">${msg.info.channel}</span> (${msg.info.memberCount}): </span>${msg.info.topic}</span>' +
            '</span>',
        retryRegistration: '{{tmpl "timestamp"}}<span class="clientMsg">' +
            '{{tmpl "notePrefix"}} <span class="message no-decorate">Retrying registration with nickname <span class="nick">${self.irc.state.nick}</span></span>' +
            '</span>'
    };

    //                  [-scheme---------][-hostname------------][-port][-path----------][-querystring-----------------------------------------------------][anchor]
    var linkifyRegex = /\b([a-z]{2,8}:\/\/([\w\-_]+(\.[\w\-_]+)*)(:\d+)?(\/[^\s\?\/<>]*)*(\?\&*([^\s=&#<>]+(=[^\s=&#<>]*)?(&[^\s=&#<>]+(=[^\s=&#<>]*)?)*)?)?(#\S+)?)/gi;

    // History of users for autoreply suggestions.
    var autoReplyList = [ ];

    // Autoreply index against autoReplyList array.
    var autoReplyIndex = undefined;
    
    // Auto complete setTimeout handle.
    var autoCompleteTimeoutHandle;
    
    // Auto complete list of term objects in the form:
    // { type: 'nick'|'channel', value: string }
    var autoCompleteList = undefined;
    
    // Auto complete suggest index against list of terms.
    var autoCompleteIndex = undefined;
    
    // Auto complete suggest index of value placed in userEntry.
    var autoCompleteTermIndex = undefined;

    // Current term string in userEntry when autoComplete presents suggestions.
    var autoCompleteTerm = undefined;
    
    // User provided term used for scanning autocomplete suggestions.
    // This contains the initial search term the user entered when scanAutoComplete() was called.
    var autoCompleteSpec = undefined;
    
    // Starting position of autoCompleteTerm.
    var autoCompleteTermPosition = undefined;

    // User entry history log.  First entry is scratch buffer from last unsent entry.
    var userEntryHistory = [''];
    var userEntryHistoryIndex = undefined;
    
    //
    // Private methods.
    //
    // Write HTML line to ircConsole.
    var writeLine = function (self, html) {
        layout.messageCount++;
        incrementNotificationMessageCount(self);

        var ircContent = self.ircElement.find('.ircConsole .content');
        var lineElement;

        var write = function (element) {
            // Is the console's scroll within 4 pixels from the bottom?
            var atBottom = layout.isAtBottom(self);
            
            // Roll off oldest line if at maximum lines.
            for (var lineCount = ircContent.find('.line').length; lineCount >= self.options.maximumConsoleLines; lineCount--) {
                ircContent.find('.line').first().remove();
            }

            // Auto decorate nicks and channels in message.
            var channel = element.find('.prefix .channel').text();
            element.closest('.channelMsg,.privateMsg,.TOPIC,.LIST,.serverMsg,.clientMsg').find('.message')
                .each(function () {
                    linkifyURLs(this);
                    decorateChannels(this);
                    decorateNicks(self, this, channel);
                });
            
            // Add doubleclick handler on nick and channel to auto-query.
            element.find('.nick,.channel')
                .hover(hoverClickableHandler, leaveClickableHandler)
                .dblclick(function () { dblclickChannelNickHandler.call(this, self); });
                
            // Detect if my nick was mentioned in a channel message.
            element.closest('.channelMsg').find('.message .nick')
                .filter(function () {
                    return self.irc.state !== undefined && self.stricmp($(this).text(), self.irc.state.nick) === 0;
                })
                .first()
                .filter(function () {
                    // Check if this message is written by me.  If I wrote it, skip highlighting.
                    var prefixNick = element.find('.prefix .nick').text();
                    return self.irc.state !== undefined && self.stricmp(prefixNick, self.irc.state.nick) !== 0;
                })
                .each(function () {
                    element.closest('.channelMsg').addClass('nickHighlight');
                });

            // Add line to console.
            var lineElement = $('<div class="line"/>')
                .attr('mc', layout.messageCount)
                .append(element)
                .appendTo(ircContent);
                
            if (!layout.isWindowFocused) {
                if (layout.blurMessageCount === (layout.messageCount - 1)) {
                    var content = self.ircElement.find('.ircConsole .content');
                    content.find('.line.viewed').removeClass('viewed');
                }
                lineElement
                    .addClass('new')
                    .css('opacity', '0.5');
            }
                
            // Auto scroll to bottom if currently at bottom.
            if (atBottom) layout.scrollToBottom(self);
            
            return lineElement;
        };
        
        if (typeof(html) === 'object') {
            $.each(html, function (i, html) {
                var element = $('<div/>').append(html);
                lineElement = write(element.contents());
            });
        }
        else {
            var element = $('<div/>').append(html);
            lineElement = write(element.contents());
        }
        
        return lineElement;
    };

    // Equivalent of find("*"), but only returns text nodes.
    // Returns jQuery object.
    var findTextNodes = function (node) {
        var textNodes = $();
        
        $(node).contents().each(function () {
            if (this.nodeType === 3) {
                textNodes = textNodes.add(this);
            }
            else {
                // Recurse children.
                textNodes = textNodes.add(findTextNodes(this));
            }
        });
    
        return textNodes;
    };

    // Filter findTextNodes to only those text nodes that qualify for decoration.
    // Returns jQuery object.
    var findTextNodesForDecoration = function (el) {
        return findTextNodes(el).filter(function () {
            var $node = $(this);
            // Exclude elements tagged with no-decorate class.
            return $(this).parents('.no-decorate').length === 0;
        });
    };
    
    // Convert URL patterns into HTML links.
    var linkifyURLs = function (el) {
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;

            // Use regex to isolate URL patterns, replace with hyperlink elements.
            var html = $node.text().replace(linkifyRegex, function (m, url) {
                modified = true;
                
                // Special case: strip trailing symbols that are probably not intended as part of the URL.
                trailingText = url.match(/[)>,\.;:'"]$/);
                if (trailingText !== null)
                    url = url.substring(url, url.length - trailingText[0].length);
                
                var n = $('<div/>')
                    .append($('<a/>')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .attr('class', 'no-decorate')
                        .text(url));
                        
                if (trailingText !== null)
                    n.append(document.createTextNode(trailingText[0]));
                
                return n.html();
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };
    
    // Decorate nicks found in text with span.
    var decorateNicks = function (self, el, channel) {
        var nicks;
        if (self.irc.state !== undefined) {
            nicks = $.map(self.irc.state.users, function (val, key) { return key; });
        }

        if (nicks === undefined || nicks.length === 0) return;
        
        // Convert array of nicks to regex expression.
        var nickExpr = $.map(nicks, function (nick) {
            // Escape regex symbols.
            return nick.replace(/([?*|.^$()\[\]{}\\/])/, "\\$1");
        }).join('|');
        var re = new RegExp("\\b(" + nickExpr + ")\\b", 'ig');
        
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;
            var html = $node.text().replace(re, function (m, nick) {
                var colorizeNumber;
                if (channel !== undefined && self.isChannel(channel)) {
                    // Lookup nick's colorize number for given channel.
                    if (self.irc.state.channels[channel] !== undefined &&
                        self.irc.state.channels[channel].members[nick] !== undefined) {
                        colorizeNumber = self.irc.state.channels[channel].members[nick].colorizeNumber;
                    }
                }
                
                modified = true;

                if (colorizeNumber !== undefined) {
                    return '<span class="nick color' + colorizeNumber + ' no-decorate">' + nick + '</span>';
                }
                else {
                    return '<span class="nick no-decorate">' + nick + '</span>';
                }
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };

    // Decorate channel-like text with span.
    var decorateChannels = function (el) {
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;
            var html = $node.text().replace(/(^|[\s,:\cg])(#[^\s,:\cg]+)\b/g, function (m, text, channel) {
                modified = true;
                
                return text + '<span class="channel no-decorate">' + channel + '</span>';
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };

    // Get colorize number associated with nick in channel from state object.
    var getColorizeNumber = function (self, nick, channel) {
        var channelDesc = self.irc.state.channels[channel];
        if (channelDesc === undefined) return;
        
        return channelDesc.members[nick] !== undefined ?
            channelDesc.members[nick].colorizeNumber : undefined;
    };

    // Add nick to recent message users list for use with autoreply suggestions.
    var addToAutoReplyList = function (self, nick) {
        if (self.stricmp(nick, self.irc.state.nick) !== 0) {
            autoReplyList = $.grep(autoReplyList, function (val) {
                // Remove from array, if exists.
                return self.stricmp(val, nick) !== 0;
            });
            autoReplyList.unshift(nick);
            
            // Preserve placement of auto complete reply index so that additions to the list don't interfere.
            if (autoReplyIndex !== undefined) autoReplyIndex++;
        }
    };

    // Accept presented autoreply.
    var acceptAutoReply = function (self) {
        if (autoReplyIndex !== undefined) {
            // Accept autoreply.
            // User entry value and caret are already set from incrementAutoReply.
            // Clear autoreply state.
            autoReplyIndex = undefined;

            self.ircElement.find('.userEntry')
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };

    // Reject presented autoreply.
    var rejectAutoReply = function (self) {
        if (autoReplyIndex !== undefined) {
            // Clear user entry and autoreply state.
            autoReplyIndex = undefined;

            self.ircElement.find('.userEntry')
                .val('')
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };
                
    // Iterate over autoreply possibilities.
    var incrementAutoReply = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();
        var s = $userEntry.val();
            
        if (s === '' || autoReplyIndex !== undefined) {
            // When user entry is blank, suggest autoreply from recent users list.
            if (autoReplyList.length) {
                if (autoReplyIndex === undefined) autoReplyIndex = 0;
                
                // Suggest quick send message to next recent sender.
                var recipient = autoReplyList[autoReplyIndex];
                var s = '/msg ' + recipient + ' ';
                $userEntry.val(s);
                $userEntry[0].selectionStart = $userEntry[0].selectionEnd = s.length;
                autoReplyIndex++;
                if (autoReplyIndex >= autoReplyList.length) autoReplyIndex = 0;
                
                // Show autoreply suggestion as tooltip.
                $userEntry
                    .tooltip('close')
                    .tooltip('option', 'content', 'Reply to <span class="nick">' + recipient + '</span>')
                    .tooltip('open');
            }
        }
    };

    var queueScanAutoComplete = function (self) {
        if (autoCompleteTimeoutHandle !== undefined) clearTimeout(autoCompleteTimeoutHandle);
        
        autoCompleteTimeoutHandle = setTimeout(function () {
            autoCompleteTimeoutHandle = undefined;
            scanAutoComplete(self);
        }, 200);
    };
    
    // Check for keyword at cursor for an autocomplete suggestion.
    var scanAutoComplete = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();
        var value = $userEntry.val();
        var position = $userEntry[0].selectionStart;
        var matches = [];

        // If cursor is at beginning, cancel autocomplete.
        if (position > 0) {
            // Position must be on a word boundary.
            // If cursor is in the middle of a word or not on a word at all, cancel autosuggest.
            // Keyword may be bounded by white space or certain punctuation.
            var lvalue = value.substr(0, position);
            var termMatch = /([^\s,\.\/\\]+)$/.exec(lvalue);
            var rvalue = value.substr(position);
            
            if (termMatch !== null && /^([\s,\.\/\\]|$)/.test(rvalue)) {
                // term is valid.
                autoCompleteSpec = autoCompleteTerm = termMatch[1];
                autoCompleteTermPosition = position - autoCompleteSpec.length;
                var term = autoCompleteTerm.toLowerCase();
                
                // Scan nicks.
                var channel = self.irc.state.channels[self.irc.target()];
                if (channel !== undefined) {
                    $.each(channel.members, function (nick) {
                        if (term === nick.substr(0, term.length).toLowerCase() && nick !== self.irc.state.nick) {
                            matches.push({ type: 'nick', value: nick });
                        }
                    });
                }
                
                // Scan channels.
                $.each(self.irc.state.channels, function (channel) {
                    if (term === channel.substr(0, term.length).toLowerCase()) {
                        matches.push({ type: 'channel', value: channel });
                    }
                });
            }
        }

        if (matches.length === 0) {
            rejectAutoComplete(self);
        }
        else {
            // Prep match list.
            matches.sort(function (a, b) { return a.value.localeCompare(b.value) });
            if (window.console) {
                console.log('autoComplete matches:');
                console.log(matches);
            }
            
            // Show tooltip with first match.
            autoCompleteList = matches;
            autoCompleteIndex = 0;
            autoCompleteTermIndex = undefined;
            updateAutoCompleteTooltip(self);
            
            // Hack to make incrementAutoComplete() pick up the first term on Tab.
            autoCompleteIndex = -1;
        }
    };
    
    var updateAutoCompleteTooltip = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();

        if (autoCompleteList.length > 0) {
            // Show next 5 suggestions in tooltip.
            // Decorate suggestion text based on type.
            var tooltipContentList = [];

            for (var i = 0; i < 5 && i < autoCompleteList.length; i++) {
                var matchIndex = i + autoCompleteIndex;
                if (matchIndex >= autoCompleteList.length) matchIndex -= autoCompleteList.length;
                var match = autoCompleteList[matchIndex];
                var content = $('<span />').text(match.value).html();
                
                if (match.type === 'nick') {
                    var colorizeNumber = getColorizeNumber(self, match.value, self.irc.target());
                    content = '<span class="nick color' + colorizeNumber + '">' + content + '</span>';
                }
                else if (match.type === 'channel')
                    content = '<span class="channel">' + content + '</span>';
                
                // Identify the 'active' suggestion placed in userEntry.
                if (autoCompleteTermIndex !== undefined && match.value === autoCompleteList[autoCompleteTermIndex].value)
                    content = '<span class="activeSuggestion">' + content + '</span>';
                    
                tooltipContentList.push(content);
            }
            
            // Append ellipsis if more suggestions are available.
            if (autoCompleteList.length > 5) tooltipContentList.push('... (' + (autoCompleteList.length - 5) + ' more)');
            
            var tooltipContent = tooltipContentList.join(', ');
            $userEntry
                .tooltip('option', 'content', tooltipContent)
                .tooltip('open');
        }
        else {
            $userEntry
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };
    
    var incrementAutoComplete = function (self, step) {
        if (autoCompleteList !== undefined) {
            if (step === undefined) step = 1;
            
            // Parse out old term from userEntry.
            var $userEntry = self.ircElement.find('.userEntry').first();
            var value = $userEntry.val();
            var lvalue = value.substr(0, autoCompleteTermPosition);
            var rvalue = value.substr(autoCompleteTermPosition + autoCompleteTerm.length);

            // Get next suggested term.
            autoCompleteIndex = autoCompleteTermIndex = (autoCompleteIndex + step) % autoCompleteList.length;
            autoCompleteTerm = autoCompleteList[autoCompleteIndex].value;
            if (lvalue.length == 0) autoCompleteTerm += ': ';

            // Place term into userEntry.
            var newValue = lvalue + autoCompleteTerm + rvalue;
            $userEntry.val(newValue);
            $userEntry[0].selectionStart = $userEntry[0].selectionEnd = autoCompleteTermPosition + autoCompleteTerm.length;

            // Update tooltip.
            updateAutoCompleteTooltip(self);
        }
    };

    var rejectAutoComplete = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();

        if (autoCompleteTerm !== undefined) {
            // Parse out old term from userEntry.
            var value = $userEntry.val();
            var lvalue = value.substr(0, autoCompleteTermPosition);
            var rvalue = value.substr(autoCompleteTermPosition + autoCompleteTerm.length);
            
            // Place original spec into userEntry.
            var newValue = lvalue + autoCompleteSpec + rvalue;
            $userEntry.val(newValue);
            $userEntry[0].selectionStart = $userEntry[0].selectionEnd = autoCompleteTermPosition + autoCompleteSpec.length;
        }
        
        autoCompleteList = undefined;
        autoCompleteTerm = undefined;
        autoCompleteTermPosition = undefined;
        
        $userEntry
            .tooltip('option', 'content', '')
            .tooltip('close');
    };

    var hoverClickableHandler = function () {
        $(this).addClass('ui-state-hover');
    };
    
    var leaveClickableHandler = function () {
        $(this).removeClass('ui-state-hover');
    };
    
    var dblclickChannelNickHandler = function (self) {
        if (self.irc.state.isActivated) {
            // Get text of element, ignoring child elements.
            var target = $(this)
                .clone()
                .children()
                .remove()
                .end()
                .text();
                
            // Unselect doubleclicked text.
            self.clearSelection();

            if (self.irc.state !== undefined && self.stricmp(target, self.irc.state.nick) !== 0) {
                if (self.isChannel(target)) {
                    // Check if joined to this channel.
                    if (self.irc.state !== undefined && self.irc.state.channels[target] === undefined)
                        self.sendLine('/join ' + target);
                    else
                        self.queryTarget(target);
                }
                else {
                    self.queryTarget(target);
                }

                self.ircElement.find('.userEntry').focus();
            }
        }
    };

    var refreshSideBar = function (self) {
        if (!layout.freezeSideBar) {
            // TODO: Incrementally update channel/member lists to avoid rendering flaws of concurrent actions,
            // such as incoming messages and user actions both changing state.
            var channelList = self.ircElement.find('.sideBar ul.channelList');
            var originalScrollTop = channelList[0].scrollTop;
                
            channelList.empty();

            $.each(self.getJoinedChannels(), function (i, channel) {
                var channelDesc = self.irc.state.channels[channel];
                var memberCount = self.getLength(channelDesc.members);
                var channelElement = $('<li><span class="channel">' + channel + '</span><span class="memberCount">(' + memberCount + ')</span><span class="leaveButton" title="Leave channel"></span></li>')
                    // Set topic as tooltip.
                    .find('.channel')
                        .attr('title', (channelDesc.topic !== undefined) ? channelDesc.topic : 'No topic set')
                        .end()
                    // Setup leave channel icon.
                    .find('.leaveButton')
                        .click(function () {
                            if (self.irc.state.isActivated) {
                                $(this).parent('li').addClass('leaving');
                                self.sendLine('/leave ' + channel);
                            }
                        })
                        .end()
                    .appendTo(channelList);
                
                var memberList = $('<ul class="memberList"/>')
                    .appendTo(channelElement);
                    
                $.each(self.getChannelMembers(channel), function (i, member) {
                    var memberDesc = channelDesc.members[member];
                    var colorizeNumber = memberDesc.colorizeNumber;
                    $('<li><span class="mode">' + memberDesc.mode + '</span><span class="nick color' + colorizeNumber + '">' + member + '</span></li>')
                        .appendTo(memberList);
                });
            });
            
            // Scroll back to original spot.
            channelList[0].scrollTop = originalScrollTop;
            
            // Apply doubleclick handler to channels and nicks.
            channelList.find('.nick,.channel')
                .hover(hoverClickableHandler, leaveClickableHandler)
                .dblclick(function () { dblclickChannelNickHandler.call(this, self); });
        }
    };

    // Resize elements to proper alignment based on ircConsole's dimensions.
    var alignUI = function (self) {
        var ircConsole = self.ircElement.find('.ircConsole');
        var ircContent = self.ircElement.find('.ircConsole .content');
        var userEntrySection = self.ircElement.find('.userEntrySection');
        var userEntryLine = self.ircElement.find('.userEntryLine');
        var userEntry = self.ircElement.find('.userEntry');
        var sideBar = self.ircElement.find('.sideBar');
        var channelList = sideBar.find('.channelList');
        ircContent
            .width(ircConsole.width())
            .height(ircConsole.height());
        userEntrySection
            .outerWidth(ircConsole.outerWidth());
        userEntryLine
            .width(userEntrySection.width());
        userEntry.outerWidth(userEntryLine.width());
        sideBar.outerHeight(ircConsole.outerHeight() + userEntrySection.outerHeight());
        channelList.height(sideBar.height());
    };
    
    var compileTemplates = function () {
        $.each(templates, function (name, tmpl) {
            $.template(name, tmpl);
        });
    };

    // Update browser title from template.
    var refreshTitle = function (self) {
        var newTitle = $.tmpl('title', {
            self: self,
            layout: layout,
            messageCount: layout.notificationMessageCount
        }).text();

        if (newTitle !== document.title) document.title = newTitle;
    };

    // Update title when notifications occur and user isn't focused on the browser.
    var incrementNotificationMessageCount = function (self) {
        if (!layout.isWindowFocused) {
            layout.notificationMessageCount++;
            refreshTitle(self);
        }
    };

    var getChannelsFromHash = function () {
        var channels = document.location.hash.split(',');
        if (channels[0] == '') return [ ];
        else return channels;
    };
    
    var setHashWithChannels = function (channels) {
        var hash = channels.sort().join(',');
        if (document.location.hash !== hash) document.location.hash = hash;
    };

    var newViewKey = function () {
        return Math.random().toString(36).substr(2, 8);
    };
    
    var getQueryString = function () {
        return location.search.substring(1);
    };
    
    // http://stackoverflow.com/a/647272/3347
    var parseQueryString = function (queryString) {
        var result = { };
        var re = /([^&=]+)=([^&]*)/g;
        var m;
        
        while (m = re.exec(queryString)) {
            result[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
        }

        return result;
    };
    
    toQueryString = function (arr) {
        var args = $.map(arr, function (val, key) {
            if (val === undefined || val === null)
                return encodeURIComponent(key);
            else
                return encodeURIComponent(key) + '=' + encodeURIComponent(val);
        });
        return args.join('&');
    };

    //
    // Public methods.
    //
    layout = {
        messageCount: 0,                    // Console message counter.
        notificationMessageCount: 0,        // Number of messages received while not focused on browser.
        blurMessageCount: undefined,        // Message count at time of blur event.
        isWindowFocused: true,
        freezeSideBar: false,               // True to disregard UI updates when calling refreshSideBar.
        warnOnUnload: true,                 // Warn user when attempting to navigate away from page.

        initialize: function (self, options) {
            self.ircElement
                .addClass('chatmore')
                .addClass('-fullpage-layout')
                .addClass('ui-widget')
                .append($(
                    '<div style="float:left;overflow:hidden">' +
                        '<div class="ircConsole ui-widget-content ui-corner-tl"><div class="content ui-corner-all"/></div>' +
                        '<div class="userEntrySection ui-widget-content ui-corner-bl">' +
                            '<div class="userEntryModeLine">' +
                                '<div class="activationIndicator"/>' +
                                '<div class="nickLabel nick"/>' +
                                '<div class="targetFragment" style="display:none"><div class="targetLabel"/></div>' +
                            '</div>' +
                            '<div class="userEntryLine"><input type="text" class="userEntry" /></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="sideBar ui-widget ui-widget-content ui-corner-right"><ul class="channelList"/></div>'
                ));
            
            alignUI(self);
            compileTemplates(self);

            // Parse hash string for channels.
            var channels = getChannelsFromHash();
            if (channels.length > 0) self.autoJoinChannels = channels;

            // Track browser window focus.
            $(window)
                .on('focus.chatmore_default', function () {
                    // Restore title when user comes back to the window.
                    setTimeout(function () {
                        layout.notificationMessageCount = 0;
                        refreshTitle(self);
                    }, 200);
                    
                    if (!layout.isWindowFocused) {
                        layout.isWindowFocused = true;
                        self.ircElement.find('.userEntry').focus();
                        
                        // Indicate new messages since blur.
                        if (layout.blurMessageCount) {
                            var msgElements = self.ircElement.find('.ircConsole .content > .line.new');
                            msgElements.fadeTo(2000, 1, 'easeOutExpo', function () {
                                msgElements
                                    .removeClass('new')
                                    .addClass('viewed');
                            });
                        }
                        
                        layout.blurMessageCount = undefined;
                    }
                })
                .on('blur.chatmore_default', function () {
                    // Start tracking new messages when losing focus.
                    layout.isWindowFocused = false;
                    layout.blurMessageCount = layout.messageCount;
                })
                .on('resize.chatmore_default', function () {
                    // Resize client to match window.
                    layout.resize(self);
                })
                .on('beforeunload.chatmore_default', function () {
                    // Provide popup warning when navigating away from this page.
                    if (layout.warnOnUnload) return 'You are about to navigate away from the Chatmore IRC client, which may disconnect from your session.';
                });
            
            // Setup user entry event handlers.
            var keydownWasHandled = false;

            self.ircElement.find('.userEntry')
                .keydown(function (e) {
                    var $userEntry = $(this);
                    keydownWasHandled = false;

                    if (!e.altKey && !e.ctrlKey && !e.shiftKey) {
                        if (e.keyCode === 13 /* Enter */) {
                            // Send message.
                            // Add new scratch line to user entry history.
                            userEntryHistory.unshift('');
                        
                            self.sendLine($userEntry.val());
                            $userEntry.val('');
                            
                            // Reset user entry history index.
                            self.userEntryHistoryIndex = undefined;

                            // Reject any autocomplete suggestions.
                            if (autoReplyIndex !== undefined)
                                rejectAutoReply(self);
                            else
                                rejectAutoComplete(self);
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode === 27 /* Escape */) {
                            if (autoReplyIndex !== undefined)
                                rejectAutoReply(self);
                            else
                                rejectAutoComplete(self);
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode == 8 /* Backspace */ || e.keyCode == 46 /* Delete */) {
                            // Backspace/Delete rejects an autoreply.
                            if (autoReplyIndex !== undefined) {
                                rejectAutoReply(self);
                                
                                keydownWasHandled = true;
                                return false;
                            }
                                
                            // Cancel autocomplete suggestion, then rescan on backspace or delete.
                            queueScanAutoComplete(self);
                        }
                        else if (e.keyCode === 9 /* Tab */) {
                            // Tab through auto replies if line is empty.
                            if ($userEntry.val() === '' || autoReplyIndex !== undefined) {
                                incrementAutoReply(self);
                            }
                            // Scan for autocomplete if no suggestion is present.
                            else if (autoCompleteList === undefined) {
                                scanAutoComplete(self);
                                incrementAutoComplete(self);
                            }
                            // Accept a presented autocomplete suggestion.
                            else {
                                incrementAutoComplete(self);
                            }
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode === 38 /* Arrow up */ || e.keyCode === 40 /* Arrow down */) {
                            if (userEntryHistoryIndex === undefined && userEntryHistory.length > 1) {
                                // Start browsing history, if any exists.
                                userEntryHistoryIndex = 0;
                            }
                            
                            if (userEntryHistoryIndex !== undefined) {
                                // Ensure no auto complete is presented.
                                rejectAutoReply(self);
                                rejectAutoComplete(self);

                                if (e.keyCode === 38) {
                                    // Go to next oldest history entry.
                                    userEntryHistoryIndex++;
                                    if (userEntryHistoryIndex >= userEntryHistory.length)
                                        userEntryHistoryIndex = 0;
                                }
                                else {
                                    // Go to next newest history entry.
                                    userEntryHistoryIndex--;
                                    if (userEntryHistoryIndex < 0)
                                        userEntryHistoryIndex = userEntryHistory.length - 1;
                                }
                            
                                // Display history in user entry.
                                var entry = userEntryHistory[userEntryHistoryIndex];
                                $userEntry.val(entry);
        
                                // Place caret at end of line.
                                this.selectionStart = entry.length;
                                this.selectionEnd = this.selectionStart;
                            }
                            
                            keydownWasHandled = true;
                            return false;
                        }                    
                    }
                })
                .keypress(function (e) {
                    var $userEntry = $(this);
                    
                    if (keydownWasHandled) {
                        keydownWasHandled = false;
                        return false;
                    }

                    if (autoReplyIndex !== undefined) {
                        // Typing text will accept a presented autoreply.
                        acceptAutoReply(self);
                    }

                    // Store current entry in first history element as scratch buffer.
                    userEntryHistory[0] = $userEntry.val() + String.fromCharCode(e.which);

                    queueScanAutoComplete(self);
                })
                // Setup tooltip.
                .tooltip({
                    items: '.userEntry',
                    show: { effect: 'fade', duration: 250 },
                    position: { my: 'left top', at: 'left bottom' },
                    track: false,
                    open: function (e, ui) {
                        // Move tooltip div to inside ircElement so that CSS styles apply.
                        ui.tooltip.appendTo(self.ircElement);
                    }
                })
                .focus();
            
            layout.resize(self);
        },
        destroy: function () {
            // Clean up.
            $(window).off('.chatmore_default');
        },
        writeTemplate: function (self, templateName, data) {
            switch (templateName) {
            case 'outgoingPrivateMsg':
                // For outgoing private messages to a user, record the target nick in autoreply list.
                if (!self.isChannel(data.msg.info.target)) {
                    addToAutoReplyList(self, data.msg.info.target);
                }
                break;
            }

            data.self = self;
            data.layout = layout;
            var el = $('<div/>')
                .append($.tmpl(templateName, data));
            return writeLine(self, el.html());
        },
        resize: function (self, width, height) {
            if (width && height) {
                var ircConsole = self.ircElement.find('.ircConsole');
                var sideBar = self.ircElement.find('.sideBar');
                var userEntrySection = self.ircElement.find('.userEntrySection');
                
                ircConsole
                    .outerWidth(width - sideBar.outerWidth())
                    .outerHeight(height - userEntrySection.outerHeight());
                
                alignUI(self);
            }
            else {
                // Resize to fit.
                var parent = self.ircElement.parent();
                var atBottom = layout.isAtBottom(self);
                
                layout.resize(self,
                    $(window).width() - parent.outerWidth() + parent.width(),
                    $(window).height() - parent.outerHeight() + parent.height());
                
                if (atBottom) layout.scrollToBottom(self);
            }
        },
        scrollToBottom: function (self) {
            var ircContent = self.ircElement.find('.ircConsole .content');
            ircContent[0].scrollTop = ircContent[0].scrollHeight;
        },

        //
        // Property getters.
        //
        // Determine if IRC console is scrolled to the bottom.
        isAtBottom: function (self) {
            var ircContent = self.ircElement.find('.ircConsole .content');
            return (ircContent[0].scrollTop + 4) >= (ircContent[0].scrollHeight - ircContent[0].clientHeight);
        },
        
        //
        // Event handlers.
        //
        onStateChanged: function (self) {
            //if (window.console) console.log('Plugin event: stateChanged');
            refreshSideBar(self);
            setHashWithChannels(self.irc.state.getChannels());
        },
        onLocalMessage: function (self, message, type, data) { },
        onProcessingMessage: function (self, msg) { },
        onProcessedMessage: function (self, msg) {
            //if (window.console) console.log('Plugin event: processedMessage');
            if (msg.type === 'servermsg' && msg.code === 402) {
                if (window.console) console.warn('Got session deleted error.  Generating new viewKey and reactivating...');
                
                // Session deleted error during activation.  Generate new viewKey and reactivate.
                var query = parseQueryString(getQueryString());
                query['viewKey'] = newViewKey();

                if (window.history.replaceState) {
                    // HTML5: Restart client with new viewKey without reloading; update URL to reflect viewKey.
                    var updatedUrl = document.location.pathname + '?' + toQueryString(query) + document.location.hash;
                    window.history.replaceState(null, document.title, updatedUrl);

                    var options = $.extend({ }, self.options);
                    options.viewKey = query['viewKey'];
                    options.channels = getChannelsFromHash();
                    $('#chatmore')
                        .chatmore(options)
                        .chatmore('resize');
                }
                else {
                    // HTML4: Redirect back with new viewKey.
                    layout.warnOnUnload = false;
                    document.location.search = '?' + toQueryString(query);
                }
            }
            else {
                switch (msg.command) {
                case 'PRIVMSG':
                    if (self.stricmp(msg.info.target, self.irc.state.nick) === 0) {
                        if (!msg.info.isAction) {
                            // Add this sender to the history of users.
                            addToAutoReplyList(self, msg.prefixNick);
                        }
                    }
                    break;
                case 'NOTICE':
                    if (self.stricmp(msg.info.target, self.irc.state.nick) === 0) {
                        // Add this sender to the history of users.
                        addToAutoReplyList(self, msg.prefixNick);
                    }
                    break;
                }
            }
        },
        onSendingMessage: function (self, rawMsg) { },
        onErrorSendingMessage: function (self, xhr, rawMsg) { },
        onSentMessage: function (self, rawMsg) { },
        onActivatingClient: function (self, stage, message, params) {
            if (stage === 'resuming' || stage === 'activated') {
                // Once activated, the sidebar can be refreshed.
                layout.freezeSideBar = false;
            }
        },
        onDeactivatingClient: function (self) {
            // Disable updates to the sidebar while in auto-reconnection state.
            if (self.enableAutoReactivate && self.reactivateAttempts < self.options.reactivateAttempts)
                layout.freezeSideBar = true;
            else
                layout.freezeSideBar = false;
        },

        //
        // Internal methods.
        //
        getColorizeCSSClass: function (self, nick, channel) {
            var number = getColorizeNumber(self, nick, channel);
            return number !== undefined ? 'color' + number : '';
        }
    };

    // Register layout.
    $.chatmore('layouts')['default'] = layout;
})();
