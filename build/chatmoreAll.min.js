function chatmoreState() {
    var state = this;
    var colorizeMin = 0;
    var colorizeMax = 31;
    
    // Get FNV-1 hash on a string.
    // http://isthe.com/chongo/tech/comp/fnv/
    // 'hash' is a previous hash to chain.
    var getFNV1 = function (n, hash) {
        if (hash === undefined) hash = 2166136261;
        
        for (var i = 0; i < n.length; i++) {
            hash *= 16777619;
            hash ^= n.charCodeAt(i);
            hash &= 0xffffffff;
        }
        
        return hash;
    };
    
    var isArrayEmpty = function (arr) {
        for (var key in arr) {
           if (arr.hasOwnProperty(key)) return false;
        }
        
        return true;
    };

    state.isModified = false;
    
    // isActivated = true when init.php returns successful connection message.
    state.isActivated = false;
    
    // isRegistered = true when welcome message is received, indicating nickname is valid.
    state.isRegistered = false;
    state.registrationAttemptCount = 0;

    state.nick = undefined;
    state.ident = undefined;
    state.realname = undefined;
    state.channels = {};
    state.users = {};
    
    // Epoch time of last message from recv.php.
    state.lastRecvTime = undefined;
    state.messageCount = 0;
    
    // Session id returned from init.php during activation.
    state.sessionId = undefined;

    state.getChannels = function () {
        var channels = [ ];
        for (var channel in state.channels) {
            channels.push(channel);
        }
        return channels;
    };
    
    state.getUsers = function () {
        var users = [ ];
        for (var user in state.users) {
            users.push(user);
        }
        return users;
    };
    
    state.addChannel = function (channel) {
        if (state.channels[channel] === undefined) {
            //if (window.console) console.log('addchannel(' + channel + ')');
            state.channels[channel] = new channelDesc();
            state.isModified = true;
        }
        
        return state.channels[channel];
    };
    
    state.addUser = function (nick) {
        if (state.users[nick] === undefined) {
            //if (window.console) console.log('addUser(' + nick + ')');
            state.users[nick] = new userDesc();
            state.isModified = true;
        }
        
        return state.users[nick];
    };
    
    state.removeChannel = function (channel) {
        if (state.channels[channel] !== undefined) {
            //if (window.console) console.log('removeChannel(' + channel + ')');
            delete state.channels[channel];
            state.isModified = true;
        }
    };
    
    state.removeUser = function (nick) {
        if (state.users[nick] !== undefined) {
            //if (window.console) console.log('removeUser(' + nick + ')');
            delete state.users[nick];
            state.isModified = true;
        }
    };

    state.clearChannels = function () {
        if (!isArrayEmpty(state.channels)) {
            //if (window.console) console.log('clearChannels()');
            state.channels = {};
            state.isModified = true;
        }
    };
    
    state.clearUsers = function () {
        if (!isArrayEmpty(state.users)) {
            //if (window.console) console.log('clearUsers()');
            state.users = {};
            state.isModified = true;
        }
    };
    
    // Describes a channel on the IRC network.
    function channelDesc() {
        this.mode = undefined;
        
        // = public, * private, @ secret
        this.visibility = undefined;
        
        this.topic = undefined;
        this.topicSetByNick = undefined;
        
        // Epoch timestamp
        this.topicSetTime = undefined;
        
        // Array of $nick => channelMemberDesc objects
        this.members = {};
        
        this.lastRPL_NAMREPLY = 0;
        this.lastRPL_ENDOFNAMES = 0;
        
        this.addMember = function (nick) {
            if (this.members[nick] === undefined) {
                //if (window.console) console.log('addMember(' + nick + ')');
                member = new channelMemberDesc();
                member.mode = '';
                
                // Generate colorize number based on nick.
                nickHash = getFNV1(nick);
                member.colorizeNumber = nickHash % (colorizeMax - colorizeMin + 1) + colorizeMin;
                this.members[nick] = member;
                
                state.isModified = true;
                
                //if (window.console) console.log('colorize ' + nick + ': ' + member.colorizeNumber + ', checksum: ' + nickHash);
            }
            
            return this.members[nick];
        };
        
        this.removeMember = function (nick) {
            if (this.members[nick] !== undefined) {
                //if (window.console) console.log('removeMember(' + nick + ')');
                delete this.members[nick];
                state.isModified = true;
            }
        };
        
        this.clearMembers = function () {
            if (!isArrayEmpty(this.members)) {
                //if (window.console) console.log('clearMembers()');
                this.members = {};
                state.isModified = true;
            }
        };
    }
    
    // Describes a member in a channel.
    function channelMemberDesc() {
        // Nick prefixes: http://www.geekshed.net/2009/10/nick-prefixes-explained/
        // ~ owners
        // & admins
        // @ full operators
        // % half operators
        // + voiced users
        this.mode = undefined;
        this.colorizeNumber = undefined;
    }
    
    // Describes a user on the IRC network.
    function userDesc() {
        this.realname = undefined;
        this.host = undefined;
        this.mode = undefined;
    }
}
/*
Instantiate chatmore as an object.
var c = new chatmore(element, {options});
element: Associated HTML DOM object
options array: {
    viewKey: string,
    server: string,
    port: number,
    nick: string,
    realname: string,
    maxRegistrationAttempts: 3, // Maximum attempts to register in the event of a nick collision during registration.
    maxResendAttempts: 4,       // Maximum retries to resend messages after encountering an error in delivery.
    pollIntervalDelayMs: 100    // Delay between polls.
}
*/
function chatmore(element, options) {
    if (options === undefined) options = { };
    
    //
    // Private members.
    //
    var self = this;
    var local;
    local = {
        pollHandle: undefined,
        pollXhr: undefined,
        pauseRecv: false,

        // Process incoming messages.
        processMessages: function (data) {
            if (data === undefined) return false;
            
            // Timestamp when last received message processing occurs.
            self.state.lastRecvTime = new Date().getTime();
            
            $.each(data, function (key, msg) {
                $(element).trigger('processingMessage.chatmore', [ msg ]);
                
                self.state.messageCount++;

                switch (msg.type) {
                case 'recv':
                    if (window.console) {
                        if (msg.raw !== undefined) console.log(msg.raw);
                        console.log(msg);
                    }
                    
                    switch (msg.command) {
                    case 'JOIN':
                        if (self.state.channels[msg.info.channel] === undefined) {
                            self.state.addChannel(msg.info.channel);
                            
                            // Get channel mode.
                            self.sendMsg('MODE ' + msg.info.channel);
                        }
                        
                        self.state.channels[msg.info.channel].addMember(msg.prefixNick);
                        break;
                        
                    case 'PART':
                        // Clean up state when leaving channel.
                        if (self.stricmp(msg.prefixNick, self.state.nick) === 0) {
                            // Current user leaving channel, remove channel from state.
                            self.state.removeChannel(msg.info.channel);
                        }
                        else {
                            // Another user leaving channel, remove member form channel state.
                            self.state.channels[msg.info.channel].removeMember(msg.prefixNick);
                        }
                        break;
                        
                    case 'KICK':
                        $.each(msg.info.kicks, function (i, kick) {
                            if (self.stricmp(kick.nick, self.state.nick) === 0) {
                                self.state.removeChannel(kick.channel);
                            }
                            else {
                                self.state.channels[kick.channel].removeMember(kick.nick);
                            }
                        });
                        break;
                        
                    case 'MODE':
                        if (self.isChannel(msg.info.target)) {
                            if (self.state.channels[msg.info.target] !== undefined) {
                                // Request fully qualified channel mode string.
                                self.sendMsg('MODE ' + msg.info.target);
                                
                                // Get channel members to capture possible user flag changes.
                                self.sendMsg('NAMES ' + msg.info.target);
                            }
                        }
                        else {
                            // Save user mode in state.
                            self.state.addUser(msg.info.target);
                            self.state.users[msg.info.target].mode = msg.info.mode;
                            self.state.isModified = true;
                        }
                        break;

                    case 'NICK':
                        if (self.stricmp(msg.prefixNick, self.state.nick) === 0) {
                            // Change current user's nick.
                            self.state.nick = msg.info.nick;
                        }
                        
                        self.renameNick(msg.info.oldNick, msg.info.nick);
                        break;
                        
                    case 'QUIT':
                        // Remove user from state.
                        $.each(self.state.channels, function (i, channel) {
                            channel.removeMember(msg.prefixNick);
                        });
                        
                        self.state.removeUser(msg.prefixNick);
                        break;

                    case '001': // Welcome
                        // If we get the welcome message, we are successfully registered.
                        if (!self.state.isRegistered) {
                            self.state.isRegistered = true;
                            self.state.isModified = true;
                        }
                        break;

                    case '324': // RPL_CHANNELMODEIS
                        if (self.state.channels[msg.info.channel] !== undefined) {
                            // Only update state if joined to this channel.
                            self.state.channels[msg.info.channel].mode = msg.info.mode;
                            self.state.isModified = true;
                        }
                        break;
                        
                    case '331': // RPL_NOTOPIC
                        if (self.state.channels[msg.info.channel] !== undefined) {
                            self.state.channels[msg.info.channel].topic = undefined;
                            self.state.isModified = true;
                        }
                        break;
                        
                    case '332': // RPL_TOPIC
                        if (self.state.channels[msg.info.channel] !== undefined) {
                            self.state.channels[msg.info.channel].topic = (msg.info.topic !== '') ? msg.info.topic : undefined;
                            self.state.isModified = true;
                        }
                        break;
                        
                    case '333': // Topic set by
                        if (self.state.channels[msg.info.channel] !== undefined) {
                            self.state.channels[msg.info.channel].topicSetByNick = msg.info.nick;
                            self.state.channels[msg.info.channel].topicSetTime = msg.info.time;
                            self.state.isModified = true;
                        }
                        break;
                        
                    case '403': // ERR_NOSUCHCHANNEL
                        // If channel is listed as joined channel, remove it.
                        self.state.removeChannel(msg.info.channel);
                        break;

                    case '353': // RPL_NAMREPLY
                        var channelDesc = self.state.addChannel(msg.info.channel);
                        channelDesc.visibility = msg.info.visibility;
                        if (channelDesc.lastRPL_NAMREPLY < channelDesc.lastRPL_ENDOFNAMES) {
                            // First RPL_NAMREPLY since last RPL_ENDOFNAMES?  Clear the channel's member listing.
                            channelDesc.clearMembers();
                        }
                        
                        $.each(msg.info.names, function (i, name) {
                            self.state.addUser(name.nick);
                            memberDesc = channelDesc.addMember(name.nick);
                            memberDesc.mode = name.mode;
                        });
                        
                        channelDesc.lastRPL_NAMREPLY = self.state.messageCount;
                        self.state.isModified = true;
                        break;
                        
                    case '366': // RPL_ENDOFNAMES
                        // Track last RPL_ENDOFNAMES for the channel.
                        // Used to terminate RPL_NAMREPLY messages.
                        if (self.state.channels[msg.info.channel] !== undefined) {
                            self.state.channels[msg.info.channel].lastRPL_ENDOFNAMES = self.state.messageCount;
                        }
                        break;
                        
                    case '433': // ERR_NICKNAMEINUSE
                        // If nick collision before successful registration, modify nick and try again.
                        if (!self.state.isRegistered) {
                            if (self.state.registrationAttemptCount < self.options.maxRegistrationAttempts) {
                                if (self.state.baseNick === undefined) self.state.baseNick = self.state.nick;
                                self.state.nick = '' + self.state.baseNick + '_' + self.state.registrationAttemptCount;
                                self.state.registrationAttemptCount++;
                                self.state.isModified = true;
                                
                                $(element).trigger('localMessage.chatmore', [ null, 'clientMsg', { code: 'R1' } ]);
                                
                                self.sendMsg('NICK ' + self.state.nick);
                            }
                            else {
                                // Trigger error message when connection attempts max out.
                                $(element).trigger('localMessage.chatmore', [ null, 'error', { code: 'RE1', maxRegistrationAttempts: self.options.maxRegistrationAttempts } ]);
                            }
                        }
                        break;
                    }
                    break;
                
                case 'servermsg':
                    if (window.console) {
                        if (msg.message !== undefined) {
                            console.log('servermsg: ' + msg.code + ' ' + msg.message);
                        }
                        else {
                            console.log('servermsg: ' + msg.code);
                        }
                    }

                    if (msg.code >= 400) {
                        if (self.state.isActivated && msg.code === 400) {
                            self.deactivateClient();
                        }
                    }
                    break;
                }

                // Raise processedMessage event.
                $(element).trigger('processedMessage.chatmore', [ msg ]);
                
                // Check if state has been changed, raise stateChanged event.
                if (self.state.isModified) {
                    $(element).trigger('stateChanged.chatmore');
                    self.state.isModified = false;
                }
            });
        }
    };
    
    //
    // Public members.
    //
    // Apply defaults for unspecified options.
    self.options = $.extend({
        maxRegistrationAttempts: 3,
        maxResendAttempts: 4,
        pollIntervalDelayMs: 100
    }, options);
    
    // Client state model.  Initialize client state with constructor parameters.
    self.state = new chatmoreState();
    self.state.server = options.server;
    self.state.port = options.port;
    self.state.nick = options.nick;
    self.state.realname = options.realname;
    self.state.isModified = true;
    
    // Get selected target nick or channel, such as by /query command.
    self.target = function (newTarget) {
        if (newTarget === undefined) {
            return local.target;
        }
        else {
            // TODO: trigger target change event.
            if (newTarget === null) newTarget = undefined;
            local.target = newTarget;
        }
    };
    
    self.activateClient = function () {
        self.state.isActivated = false;
        self.state.lastRecvTime = undefined;
        
        $(element).trigger('activatingClient.chatmore', [
            'start',
            undefined,
            { server: self.state.server, port: self.state.port }
        ]);
        
        var newConnectionFlag = true;
        var errorFlag = false;
        var errorHandler = function (message) {
            $(element).trigger('activatingClient.chatmore', [
                'error',
                message,
                { server: self.state.server, port: self.state.port }
            ]);
        };
        var ajaxErrorFunc = function (xhr, status, error) {
            errorHandler('Error during activation: ' + status + ', ' + error);
            errorFlag = true;
        };
        
        // Initialize web client.
        // Check for open connection.
        $.ajax('init.php',
            {
                async: false,
                type: 'POST',
                cache: false,
                dataType: 'json',
                data: {
                    connect: 0,
                    viewKey: options.viewKey,
                    server: self.state.server,
                    port: self.state.port
                },
                success: function (data) {
                    try {
                        local.processMessages.call(self, data);

                        $.each(data, function (idx, msg) {
                            if (msg.type === 'servermsg') {
                                // Check for connection ready message, which indicates a resumable connection.
                                if (msg.code === 200) {
                                    newConnectionFlag = false;
                                }
                                else if (msg.code > 400) {
                                    // All error codes except 400 will abort activation.
                                    errorHandler(msg.message);
                                    errorFlag = true;
                                }
                            }
                        });
                    }
                    catch (e) {
                        // Exception during activation.  Client state is undetermined.  User may need to start over.
                        if (window.console) {
                            console.error('Exception caught while processing messages:');
                            console.error(data);
                            console.error(e);
                        }
                    }
                },
                error: ajaxErrorFunc
            }
        );
        
        if (errorFlag) {
            return;
        }
            
        // Create/resume a connection.
        if (newConnectionFlag) {
            $(element).trigger('activatingClient.chatmore', [
                'connecting',
                undefined,
                {
                    server: self.state.server,
                    port: self.state.port
                }
            ]);
        }
        else {
            $(element).trigger('activatingClient.chatmore', [
                'resuming',
                undefined,
                {
                    server: self.state.server,
                    port: self.state.port
                }
            ]);
        }
        
        $.ajax('init.php',
            {
                type: 'POST',
                cache: false,
                dataType: 'json',
                data: {
                    connect: 1,
                    viewKey: options.viewKey
                },
                success: function (data) {
                    try {
                        local.processMessages.call(self, data);

                        if ($.grep(data, function (x) { return x.type === 'servermsg' && x.code === 200; }).length) {
                            // Activated.
                            $(element).trigger('activatingClient.chatmore', [
                                'activated',
                                undefined,
                                { server: self.state.server, port: self.state.port }
                            ]);
                            self.state.isActivated = true;

                            if (newConnectionFlag) {
                                // Register with IRC server.
                                self.register(self.state.nick, self.state.realname);
                            }

                            // Repeatedly poll for IRC activity.
                            var pollFunc = function () {
                                if (local.pauseRecv) {
                                    setTimeout(pollFunc, 100);
                                }
                                else {
                                    local.pollHandle = undefined;
                                    local.pollXhr = $.ajax('recv.php',
                                        {
                                            cache: false,
                                            data: {
                                                viewKey: options.viewKey
                                            },
                                            dataType: 'json',
                                            success: function (data) {
                                                // Validate data is an array.
                                                if (typeof(data) === 'object') {
                                                    try {
                                                        //if (window.console) console.debug('msg count: ' + data.length);
                                                        local.processMessages.call(self, data);
                                                    }
                                                    catch (e) {
                                                        if (window.console) {
                                                            console.error('Exception caught while processing messages:');
                                                            console.error(data);
                                                            console.error(e);
                                                        }
                                                    }
                                                }
                                                else {
                                                    // Data is invalid!
                                                    if (window.console) {
                                                        console.warn('Got invalid data:');
                                                        console.warn(data);
                                                    }
                                                }
                                            },
                                            complete: function () {
                                                // Schedule next poll.
                                                local.pollXhr = undefined;
                                                if (self.state.isActivated) {
                                                    local.pollHandle = setTimeout(pollFunc, self.options.pollIntervalDelayMs);
                                                }
                                            }
                                        });
                                }
                            };
                            setTimeout(pollFunc, 0);
                            $(element).trigger('activatedClient.chatmore', [
                                { server: self.state.server, port: self.state.port }
                            ]);
                        }
                        else {
                            // Error on activation.
                            $(element).trigger('activatingClient.chatmore', [
                                'error',
                                'Error during activation',
                                { server: self.state.server, port: self.state.port }
                            ]);
                        }
                    }
                    catch (e) {
                        // Exception during activation.  Client state is undetermined.  User may need to start over.
                        if (window.console) {
                            console.error('Exception caught while processing messages:');
                            console.error(data);
                            console.error(e);
                        }
                    }
                },
                error: ajaxErrorFunc
            });
    };

    self.deactivateClient = function () {
        if (self.state.isActivated) {
            $(element).trigger('deactivatingClient.chatmore');
            
            self.state.isActivated = false;
            
            // Ensure any running ajax call is aborted and stops recurring.
            if (local.pollHandle !== undefined) clearTimeout(local.pollHandle);
            local.pollHandle = undefined;
            if (local.pollXhr !== undefined) local.pollXhr.abort();
            local.pollXhr = undefined;
                    
            $(element).trigger('deactivatedClient.chatmore');
        }
    };
    
    // Send raw message to server.
    self.sendMsg = function (rawMsg, postCallback) {
        var sendHandler = function (resendCount) {
            var resendHandler = function () {
                // Give up after 3 resends.
                if (resendCount < self.options.maxResendAttempts) {
                    if (window.console) console.warn('Resending: ' + rawMsg);

                    // First attempt retry immediately.
                    // Successive attempts delay a moment.
                    // TODO: Parameterize the delay interval.
                    var retryDelay = resendCount > 0 ? 3000 : 100;
                    setTimeout(function () { sendHandler(resendCount + 1); }, retryDelay);
                }
            };

            $(element).trigger('sendingMessage.chatmore', [ rawMsg, resendCount ]);

            $.ajax('send.php',
                {
                    async: true,
                    type: 'POST',
                    dataType: 'json',
                    cache: false,
                    data: {
                        viewKey: options.viewKey,
                        msg: rawMsg
                    },
                    success: function (data) {
                        if (postCallback) postCallback(rawMsg);
                        $(element).trigger('sentMessage.chatmore', [ rawMsg, resendCount ]);
                
                        // Validate data is an array.
                        if (typeof(data) === 'object') {
                            try {
                                local.processMessages.call(self, data);
                            }
                            catch (e) {
                                if (window.console) {
                                    console.error('Exception caught while processing messages:');
                                    console.error(data);
                                    console.error(e);
                                }
                            }
                        }
                        else {
                            // Data is invalid!
                            if (window.console) {
                                console.warn('Got invalid data:');
                                console.warn(data);
                            }
                        
                            resendHandler();
                            
                            return false;
                        }
                    },
                    error: function (event, xhr) {
                        $(element).trigger('errorSendingMessage.chatmore', [ xhr, rawMsg, resendCount ]);
                        
                        resendHandler();
                    }
                });
        };
        
        sendHandler(0);
    };

    self.register = function (nick, realname) {
        self.state.nick = nick;
        self.state.ident = Math.floor(Math.random() * 100000000);
        self.state.realname = realname;
        self.state.isRegistered = false;
        self.state.registrationAttemptCount = 1;
        self.state.isModified = true;
        
        if (window.console) console.log('Registering user "' + self.state.nick + '" (' + self.state.realname + ') on IRC server "' + self.state.server + ':' + self.state.port + '"');
        
        self.sendMsg('USER ' + self.state.ident + ' 0 * :' + self.state.realname);
        self.sendMsg('NICK ' + self.state.nick);
    };
    
    self.sendChannelMsg = function (channel, message) {
        this.sendMsg('PRIVMSG ' + channel + ' :' + message);
    };

    self.sendPrivateMsg = function (nick, message) {
        this.sendMsg('PRIVMSG ' + nick + ' :' + message);
    };
    
    self.sendChannelAction = function (channel, message) {
        var quote = String.fromCharCode(1);
        this.sendMsg('PRIVMSG ' + channel + ' :' + quote + 'ACTION ' + message + quote);
    };

    self.sendPrivateAction = function (nick, message) {
        var quote = String.fromCharCode(1);
        this.sendMsg('PRIVMSG ' + nick + ' :' + quote + 'ACTION ' + message + quote);
    };
    
    self.sendChannelNotice = function (channel, message) {
        this.sendMsg('NOTICE ' + channel + ' :' + message);
    };

    self.sendPrivateNotice = function (nick, message) {
        this.sendMsg('NOTICE ' + nick + ' :' + message);
    };

    self.renameNick = function (oldNick, newNick) {
        // Adjust channel members.
        $.each(self.state.channels, function (i, channel) {
            if (channel.members[oldNick] !== undefined) {
                channel.members[newNick] = channel.members[oldNick];
                channel.removeMember(oldNick);
            }
        });
        
        // Adjust user list.
        self.state.users[newNick] = self.state.users[oldNick];
        self.state.removeUser(oldNick);
        
        self.state.isModified = true;
    };

    self.stricmp = function (a, b) {
        return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase());
    };

    self.isChannel = function (target) {
        return target.match(/^[#&+!][^\s,:\cg]+/);
    };
}//
// Chatmore CLI.
//
(function () {
    //
    // Private static variables.
    //
    // Registry of layout plugin instances.
    var layouts = { };

    var globalMethods = {
        layouts: function () {
            return layouts;
        }
    };

    //
    // Private static functions.
    //
    var isEmpty = function (text) {
        return text === undefined || text === null || text === '';
    };

    //
    // Global chatmore jQuery plugin.
    //
    // Exports methods defined in globalMethods.
    // Usage: $.chatmore('method', [arg], ...);
    $.chatmore = function () {
        var method = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        return globalMethods[method].apply(null, args);
    };
    
    //
    // Object chatmore jQuery plugin.
    //
    $.fn.chatmore = function () {
        // charemoreUI constructor() | constructor({options})
        if (arguments.length === 0 || typeof(arguments[0]) === 'object') {
            // Construct UI widget.
            var userOptions = arguments.length > 0 ? arguments[0] : { };
            
            // Parse options.
            var options = {
                port: 6667,
                title: document.title,
                viewKey: '',
                nick: 'user' + Math.floor(Math.random() * 10000),
                quitMessage: 'Chatmore IRC client',
                reactivateAttempts: 6,
                reactivateDelay: 10,
                layout: undefined                   // Layout name.  Undefined will pick 'default' or first layout in registry.
            };
            $.extend(options, userOptions);
            if (isEmpty(options.realname)) options.realname = options.nick;
            if (typeof(options.channel) === 'object') autoJoinChannels = options.channel;
            else if (!isEmpty(options.channel)) autoJoinChannels.push(options.channel);
                
            var getLayoutPlugin = function () {
                if (options.layout === undefined) {
                    if ('default' in layouts) {
                        return layouts['default'];
                    }
                    else {
                        for (var name in layouts) {
                            if (data.propertyIsEnumerable(prop)) return layouts[name];
                        }
                        
                        if (window.console) console.warn('Error initializing Chatmore:  No layout plugins have been loaded!');
                        return false;
                    }
                }
                else {
                    return layouts[options.layout];
                }
            };
    
            var self = {
                //
                // Private members.
                //
                ircElement: $(this),                // Chatmore parent jQuery element.
                irc: undefined,                     // Chatmore client object.
                options: options,
                autoJoinChannels: [ ],              // Channels provided at startup.
                prevState: undefined,
                enableAutoReactivate: true,
                reactivateAttempts: 0,
                isPendingActivation: false,
                layoutPlugin: getLayoutPlugin(),    // Selected layout plugin instance.
                
                // Client /command definitions.
                cmdDefs: {
                    clear: {
                        helpUsage: 'Usage: /clear',
                        helpText: 'Clear the chat console.',
                        parseParam: function () { },
                        exec: function (meta) {
                            self.ircElement.find('.ircConsole .content').html('');
                        }
                    },
                    cleartopic: {
                        helpUsage: 'Usage: /cleartopic',
                        helpText: 'Clear the selected channel\'s topic.',
                        parseParam: function (param, meta) {
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to clear the topic.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('TOPIC ' + self.irc.target() + ' :');
                        }
                    },
                    connect: {
                        helpUsage: 'Usage: /connect',
                        helpText: 'Reconnect after disconnection.',
                        parseParam: function () { },
                        exec: function (meta) {
                            if (self.isPendingActivation) {
                                meta.error = 'Error: Cannot reconnect while connection attempt is pending.  Enter /quit to abort connection attempt.';
                                return false;
                            }
                            else if (self.irc.state.isActivated) {
                                meta.error = 'Error: Cannot reconnect while still connected.';
                                return false;
                            }
                            self.irc.activateClient();
                        }
                    },
                    deop: {
                        helpUsage: 'Usage: /deop &lt;nick&gt; [nick ...]',
                        helpText: 'Revoke channel operator status from a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.deop.helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to revoke operator status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to revoke operator status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('o');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' -' + os + ' ' + nicks);
                        }
                    },
                    devoice: {
                        helpUsage: 'Usage: /devoice &lt;nick&gt; [nick ...]',
                        helpText: 'Revoke channel voice status from a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.devoice.helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to revoke voice status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to revoke voice status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('v');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' -' + os + ' ' + nicks);
                        }
                    },
                    help: {
                        helpUsage: 'Usage: /help &lt;command&gt;',
                        helpText: [
                            'Show help for client commands.',
                            'Commands:',
                            ' clear - Clear the chat console',
                            ' cleartopic - Clear the channel\'s topic (must be an operator)',
                            ' connect - Reconnect to IRC server',
                            ' join - Join a channel',
                            ' kick - Kick user from channel (must be an operator)',
                            ' leave - Leave a channel',
                            ' list - Get channel listing',
                            ' me - Send an action message',
                            ' motd - Get the server message of the day',
                            ' msg - Send a private message',
                            ' nick - Change your nick',
                            ' notice - Send a notice to a user or channel',
                            ' op/deop - Grant/revoke channel operator status to a user (must be an operator)',
                            ' query - Select a target for messaging',
                            ' quit - Quit IRC session',
                            ' quote - Send raw IRC message',
                            ' time - Get the server time',
                            ' topic - Get or set the channel\'s topic (must be an operator)',
                            ' voice/devoice - Grant/revoke channel voice to a user (must be an operator)',
                            ' who - Get info on a user'
                        ],
                        parseParam: function (param, meta) {
                            if (param === undefined) param = 'help';
                            
                            if (self.cmdDefs[param] === undefined) {
                                meta.error = 'Error: Cannot get help on unknown command "' + param + '".';
                                return false;
                            }
    
                            meta.cmd = param;
                        },
                        exec: function (meta) {
                            var cmdDef = self.cmdDefs[meta.cmd];
                            self.writeTmpl('help', { message: cmdDef.helpUsage });
                            
                            if (typeof(cmdDef.helpText) === 'object')
                                $.each(cmdDef.helpText, function (i, text) {
                                    self.writeTmpl('help', { message: text });
                                });
                            else
                                self.writeTmpl('help', { message: cmdDef.helpText });
                        }
                    },
                    join: {
                        helpUsage: 'Usage: /join &lt;#channel&gt; [key]',
                        helpText: 'Join a channel.  Include a key if the channel requires it to join.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.join.helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 2);
                            // Normalize channel name if it's missing a prefix.
                            meta.channel = params[0].replace(/^([^#&+!])/, '#$1');
                            if (params[1] !== undefined) meta.key = params[1];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to join a channel.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.joinChannel(meta.channel, meta.key);
                        }
                    },
                    kick: {
                        helpUsage: 'Usage: /kick &gt;nick&lt; [comment]',
                        helpText: 'Kick user from channel.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs.kick.helpUsage;
                            var m = /^(\S+)(\s+(.+))?/.exec(param);
                            if (m === null) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nick = m[1];
                            meta.comment = m[3];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to kick a user.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.comment !== undefined)
                                self.irc.sendMsg('KICK ' + meta.channel + ' ' + meta.nick + ' :' + meta.comment);
                            else
                                self.irc.sendMsg('KICK ' + meta.channel + ' ' + meta.nick);
                        }
                    },
                    leave: {
                        helpUsage: 'Usage: /leave [#channel] [comment]',
                        helpText: [
                            'Leave a channel.',
                            'If channel omitted, leaves channel currently selected by /query.'
                        ],
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                if (self.irc.target() === undefined) {
                                    meta.error = self.cmdDefs.leave.helpUsage;
                                    return false;
                                }
                                else {
                                    meta.channel = self.irc.target();
                                }
                            }
                            else {
                                var m = /^(\S+)(\s+(.+))?\s*$/.exec(param);
                                // Normalize channel name if it's missing a prefix.
                                meta.channel = m[1].replace(/^([^#&+!])/, '#$1');
                                if (m[3] !== undefined) meta.comment = m[3];
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to leave a channel.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.comment !== undefined)
                                self.irc.sendMsg('PART ' + meta.channel + ' :' + meta.comment);
                            else
                                self.irc.sendMsg('PART ' + meta.channel);
                        }
                    },
                    list: {
                        helpUsage: 'Usage: /list [#channel [, #channel ...] ] [server]',
                        helpText: 'Get channel listing.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                // No parameters.
                            }
                            else {
                                // Parse form: channels and server.
                                var m = /^([#&+!][^\s,:\cg]+(\s*,\s*[#&+!][^\s,:\cg]+)*)(\s+(\S+))?\s*$/.exec(param);
                                if (m !== null) {
                                    meta.channels = m[1].split(/\s*,\s*/);
                                    
                                    if (m[4] !== undefined) {
                                        meta.server = m[4];
                                    }
                                }
                                else {
                                    // Parse form: server only
                                    m = /^(\S+)\s*$/.exec(param);
                                    if (m !== null) {
                                        meta.server = m[1];
                                    }
                                    else {
                                        // Unable to parse parameters.
                                        meta.error = self.cmdDefs.list.helpUsage;
                                        return false;
                                    }
                                }
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get the channel listing.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.channels !== undefined) {
                                if (meta.server !== undefined) {
                                    self.irc.sendMsg('LIST ' + meta.channels.join(',') + ' ' + meta.server);
                                }
                                else {
                                    self.irc.sendMsg('LIST ' + meta.channels.join(','));
                                }
                            }
                            else if (meta.server !== undefined) {
                                self.irc.sendMsg('LIST ' + meta.server);
                            }
                            else {
                                self.irc.sendMsg('LIST');
                            }
                        }
                    },
                    me: {
                        helpUsage: 'Usage: /me &lt;message&gt;',
                        helpText: 'Send an action message to currently selected channel or user.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs.msg.helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.target = self.irc.target();
                            meta.message = param;
                            
                            if (isEmpty(meta.target)) {
                                meta.error = 'Error: Must select a channel or nick to send a message.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send an action message.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelAction(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelAction', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateAction(meta.target, meta.message);
                                self.writeTmpl('outgoingPrivateAction', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    mode: {
                        helpUsage: 'Usage: /mode &lt;nick | #channel&gt; [ &lt;+mode | -mode&gt; [parameters] ]',
                        helpText: [
                            'Get or change user or channel mode.',
                            'Available user modes: http://tools.ietf.org/html/rfc2812#section-3.1.5',
                            'Available channel modes: http://tools.ietf.org/html/rfc2811#section-4'
                        ],
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs.mode.helpUsage;
                            var m = /^(\S+)(\s+(\S+(\s+\S+)*))?\s*$/.exec(param);
                            if (m === null) {
                                meta.error = usage;
                                return false;
                            }
                            
                            meta.target = m[1];
                            
                            if (m[3] !== undefined)
                                meta.modes = m[3].split(/\s+/);
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to change mode.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.modes !== undefined)
                                self.irc.sendMsg('MODE ' + meta.target + ' ' + meta.modes.join(' '));
                            else
                                self.irc.sendMsg('MODE ' + meta.target);
                        }
                    },
                    motd: {
                        helpUsage: 'Usage: /motd [server]',
                        helpText: [
                            'Get the server message of the day.',
                            'If server parameter is omitted, query current server.'
                        ],
                        parseParam: function (param, meta) {
                            meta.server = param;
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get server motd.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.server !== undefined && meta.server.length > 0)
                                self.irc.sendMsg('MOTD ' + meta.server);
                            else
                                self.irc.sendMsg('MOTD');
                        }
                    },
                    msg: {
                        helpUsage: 'Usage: /msg &lt;nick|#channel&gt; &lt;message&gt;',
                        helpText: 'Send a private message to a user.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs.msg.helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            var m = /^(\S+)\s+(.+)$/.exec(param);
                            if (m === null || m.length !== 3) {
                                meta.error = usage;
                                return false;
                            }
                            meta.target = m[1];
                            meta.message = m[2];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a message.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelMsg(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelMsg', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateMsg(meta.target, meta.message);
                                //self.addToMsgSenders(meta.target);
                                self.writeTmpl('outgoingPrivateMsg', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    nick: {
                        helpUsage: 'Usage: /nick &lt;nickname&gt;',
                        helpText: 'Change your nick.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.nick.helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 1);
                            meta.nick = params[0];
    
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to change your nickname.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('NICK ' + meta.nick);
                        }
                    },
                    notice: {
                        helpUsage: 'Usage: /notice &lt;nick|#channel&gt; &lt;message&gt;',
                        helpText: 'Send a notice to a user or channel.',
                        parseParam: function (param, meta) {
                            var usage = self.cmdDefs.msg.helpUsage;
                            
                            if (param === undefined) {
                                meta.error = usage;
                                return false;
                            }
                            
                            var m = /^(\S+)\s+(.+)$/.exec(param);
                            if (m === null || m.length !== 3) {
                                meta.error = usage;
                                return false;
                            }
                            meta.target = m[1];
                            meta.message = m[2];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a notice.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.isChannel(meta.target)) {
                                self.irc.sendChannelNotice(meta.target, meta.message);
                                self.writeTmpl('outgoingChannelNotice', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                            else {
                                self.irc.sendPrivateNotice(meta.target, meta.message);
                                self.writeTmpl('outgoingPrivateNotice', {
                                    msg: {
                                        prefixNick: self.irc.state.nick,
                                        prefixUser: self.irc.state.ident,
                                        info: {
                                            target: meta.target,
                                            text: meta.message
                                        }
                                    }
                                });
                            }
                        }
                    },
                    op: {
                        helpUsage: 'Usage: /op &lt;nick&gt; [nick ...]',
                        helpText: 'Grant channel operator status to a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.op.helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to grant operator status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to grant operator status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('o');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' +' + os + ' ' + nicks);
                        }
                    },
                    query: {
                        helpUsage: 'Usage: /query &lt;nick|#channel&gt;',
                        helpText: 'Select a user or channel to send messages.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.query.helpUsage;
                                return false;
                            }
                            
                            var params = param.split(/\s+/, 1);
                            meta.target = params[0];
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to query a target.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.queryTarget(meta.target);
                        }
                    },
                    quit: {
                        helpUsage: 'Usage: /quit [comment]',
                        helpText: 'Quit IRC session.',
                        parseParam: function (param, meta) {
                            meta.comment = param;
                        
                            if (!self.irc.state.isActivated && !self.isPendingActivation) {
                                meta.error = 'Error: Must be connected to quit.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (self.irc.target() !== undefined) self.queryTarget(undefined);
                            
                            var comment = meta.comment !== undefined ? meta.comment : self.options.quitMessage;
                            self.enableAutoReactivate = false;
                            if (self.isPendingActivation) {
                                self.isPendingActivation = false;
                                self.writeTmpl('error', { message: 'Server connection aborted.' });
                            }
                            else {
                                self.irc.sendMsg('QUIT :' + comment);
                            }
                        }
                    },
                    quote: {
                        helpUsage: 'Usage: /quote &gt;IRC request message&lt;',
                        helpText: 'Send a raw IRC request based on RFC2812.',
                        parseParam: function (param, meta) {
                            meta.param = param;
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to send a raw IRC request.';
                                return false;
                            }
                            
                            if (isEmpty(meta.param)) {
                                meta.error = 'Missing parameter to /quote.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg(meta.param);
                        }
                    },
                    time: {
                        helpUsage: 'Usage: /time [server]',
                        helpText: [
                            'Get the server time.',
                            'If server parameter is omitted, query current server.'
                        ],
                        parseParam: function (param, meta) {
                            meta.server = param;
                        
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get server time.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.server !== undefined && meta.server.length > 0)
                                self.irc.sendMsg('TIME ' + meta.server);
                            else
                                self.irc.sendMsg('TIME');
                        }
                    },
                    topic: {
                        helpUsage: 'Usage: /topic [message]',
                        helpText: 'Get or set the selected channel\'s topic',
                        parseParam: function (param, meta) {
                            meta.topic = param;

                            if (self.irc.target() === undefined) {
                                meta.error = 'Error: No target selected.  Doubleclick a channel or user on the side bar or enter: /query &lt;nick|#channel&gt;.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get or set the topic.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            if (meta.topic === undefined) {
                                self.irc.sendMsg('TOPIC ' + self.irc.target());
                            }
                            else {
                                self.irc.sendMsg('TOPIC ' + self.irc.target() + ' :' + meta.topic);
                            }
                        }
                    },
                    voice: {
                        helpUsage: 'Usage: /voice &lt;nick&gt; [nick ...]',
                        helpText: 'Grant channel voice status to a user.',
                        parseParam: function (param, meta) {
                            if (param === undefined) {
                                meta.error = self.cmdDefs.voice.helpUsage;
                                return false;
                            }
                            
                            meta.channel = self.irc.target();
                            meta.nicks = param.split(/\s+/);
                            
                            if (isEmpty(meta.channel) || !self.isChannel(meta.channel)) {
                                meta.error = 'Error: Must select a channel to grant voice status.';
                                return false;
                            }
                            
                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to grant voice status.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            var os = Array(meta.nicks.length + 1).join('v');
                            var nicks = meta.nicks.join(' ');
                            self.irc.sendMsg('MODE ' + meta.channel + ' +' + os + ' ' + nicks);
                        }
                    },
                    who: {
                        helpUsage: 'Usage: /who &lt;nick | channel&gt;',
                        helpText: 'Get info on a user or all users in a channel.',
                        parseParam: function (param, meta) {
                            meta.target = param;

                            if (!self.irc.state.isActivated) {
                                meta.error = 'Error: Must be connected to get WHO information.';
                                return false;
                            }
                            
                            if (isEmpty(meta.target)) {
                                meta.error = 'Missing parameter to /quote.';
                                return false;
                            }
                        },
                        exec: function (meta) {
                            self.irc.sendMsg('WHO ' + meta.target);
                        }
                    }
                },
    
                // Send line from user entry.
                // Parse out client commands and execute action.
                // If not a command, send as message to current target.
                sendLine: function (text) {
                    // Parse out command and parameters.
                    var m = /^\/(\S+)(\s+(.+))?/.exec(text);
                    if (m) {
                        var cmd = m[1].toLowerCase();
                        var param = m[3];
                        
                        if (self.cmdDefs[cmd] === undefined) {
                            self.writeTmpl('error', { message: 'Error: Unknown client command "' + cmd + '".' });
                        }
                        else {
                            var meta = {};
                            var cmdDef = self.cmdDefs[cmd];
                            if (cmdDef.parseParam && cmdDef.parseParam(param, meta) === false) {
                                if (meta.error) self.writeTmpl('error', { message: meta.error });
                            }
                            else {
                                cmdDef.exec(meta);
                            }
                        }
                    }
                    // Send text to selected target.
                    else if (self.irc.state.isActivated) {
                        // Sanitize input.
                        if (self.irc.target() !== undefined) {
                            text = text.replace(/([\n\r])/gm, '');
                            if (text.length > 0) {
                                self.sendLine('/msg ' + self.irc.target() + ' ' + text);
                            }
                        }
                        else {
                            self.writeTmpl('error', { message: 'Error: No target selected.  Use: /query <nick|#channel> or /join <#channel>.' });
                        }
                    }
                    else {
                        self.writeTmpl('error', { message: 'Error: Cannot send message, client not activated.' });
                    }
                },
    
                getShortTimestamp: function () {
                    var d = new Date();
                    return d.getHours() + ':' + self.padZero(d.getMinutes(), 2);
                },
    
                getLongTimestamp: function () {
                    return new Date().toLocaleString();
                },
                
                padZero: function (n, digits) {
                    var z = new Array(digits + 1).join('0');
                    var pn = '' + z + n;
                    return pn.substring(pn.length - digits);
                },
    
                formatTime: function(time) {
                    var d = new Date();
                    d.setTime(time * 1000);
                    return d.toLocaleString();
                },
                
                isChannel: function (target) {
                    return target.match(/^[#&+!][^\s,:\cg]+/);
                },
    
                stricmp: function (a, b) {
                    return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase());
                },
                
                writeTmpl: function(templateName, data) {
                    self.layoutPlugin.writeTemplate(self, templateName, data);
                },
                
                startsWith: function (subject, prefix, comparer) {
                    return subject.length >= prefix.length &&
                        comparer(subject.substr(0, prefix.length), prefix) === 0;
                },
    
                // Find next match from a list, where the item is greater than seed.
                // comparer is function(a, b) returning -1, 0, or 1.
                getNextMatch: function (list, seed, comparer) {
                    if (list.length > 0) {
                        if (seed === undefined || seed === null)
                            return list[0];
                            
                        // Find next match.
                        for (var i in list) {
                            var val = list[i];
                            if (comparer(val, seed) > 0) {
                                return val;
                            }
                        }
                        
                        // Wrap around to beginning of list.
                        return list[0];
                    }
                    else {
                        return undefined;
                    }
                },
                
                clearSelection: function () {
                    if (window.getSelection) {
                        window.getSelection().removeAllRanges();
                    }
                    else if (document.selection) {
                        document.selection.empty();
                    }
                },
    
                joinChannel: function (channel, key) {
                    if (self.irc.state.channels[channel] !== undefined) {
                        // If already joined to this channel, just query it.
                        self.queryTarget(channel);
                    }
                    else {
                        if (key !== undefined)
                            self.irc.sendMsg('JOIN ' + channel + ' ' + key);
                        else
                            self.irc.sendMsg('JOIN ' + channel);
                    }
                },
    
                queryTarget: function (target) {
                    if (window.console) console.log('queryTarget(' + target + ')');
                    var prevTarget = self.irc.target();
                    
                    if (target !== prevTarget) {
                        self.irc.target(target);
    
                        self.writeTmpl(target === undefined ? 'queryOff' : 'query', {
                            target: target,
                            prevTarget: prevTarget
                        });
    
                        // Update user mode line.
                        self.ircElement.find('.targetFragment').fadeOut(null, function () {
                            self.ircElement.find('.targetLabel').text(target);
                            if (target !== undefined && target !== null) {
                                var isChannel = self.isChannel(target);
                                self.ircElement.find('.targetLabel')
                                    .removeClass(isChannel ? 'nick' : 'channel')
                                    .addClass(isChannel ? 'channel' : 'nick');
        
                                self.ircElement.find('.targetFragment').fadeIn();
                            }
                        });
                    }
                },
                
                // Handle renaming of a nick of any user.
                getJoinedChannels: function () {
                    var channels = [ ];
                    
                    if (self.irc.state !== undefined) {
                        channels = $.map(self.irc.state.channels, function (val, channel) {
                            return channel;
                        });
                    }
    
                    return channels.sort(self.stricmp);
                },
                
                getChannelMembers: function (channel) {
                    var members = [ ];
                    
                    if (self.irc.state !== undefined) {
                        var channelDesc = self.irc.state.channels[channel];
                        
                        if (channelDesc !== undefined) {
                            members = $.map(channelDesc.members, function (val, member) {
                                return member;
                            });
                        }
                    }
                    
                    return members.sort(self.stricmp);
                },
    
                // Get length of an object array.
                // Based on: http://stackoverflow.com/questions/5223/length-of-javascript-associative-array
                getLength: function (obj) {
                    if (obj.length) {
                        // Non-object array.
                        return obj.length;
                    }
                    else if (Object.keys) {
                        // Object
                        return Object.keys(obj).length;
                    }
                    else {
                        // Object.  Manually counting elements.
                        var size = 0;
                        
                        for (var key in obj) {
                            if (obj.hasOwnProperty(key)) size++;
                        }
                        
                        return size;
                    }
                },
                
                // Clone an object or array structure.  Does not preserve prototype.
                // Based on: http://my.opera.com/GreyWyvern/blog/show.dml/1725165
                clone: function(obj) {
                    var newObj = (obj instanceof Array) ? [] : {};
                    for (key in obj) {
                        newObj[key] = (obj[key] && typeof obj[key] === "object") ? self.clone(obj[key]) : obj[key];
                    }
                    return newObj;
                },
                
                //
                // Public API.
                //
                methods: {
                    // Activate client.
                    activateClient: function () {
                        self.irc.activateClient();
                        return self.ircElement;
                    },
                    // Deactivate client.
                    deactivateClient: function () {
                        self.irc.deactivateClient();
                        return self.ircElement;
                    },
                    // Resize chatmoreUI element.
                    // Omit width/height to resize to fit.
                    resize: function (width, height) {
                        self.layoutPlugin.resize(self, width, height);
                        return self.ircElement;
                    },
                    // Scroll console to bottom.
                    scrollToBottom: function () {
                        self.layoutPlugin.scrollToBottom(self);
                        return self.ircElement;
                    },
                    //
                    // Property getters.
                    //
                    // Determine if console is scrolled to the bottom.
                    isAtBottom: function () {
                        return self.layoutPlugin.isAtBottom(self);
                    },
                    //
                    // Customization API.
                    //
                    // Get layout registry hash.
                    layouts: function () {
                        return layouts;
                    },
                    // Set and initialize a layout plugin.
                    setLayout: function (name) {
                        if (name in layouts) {
                            // Clean up previous layout plugin.
                            if (self.layoutPlugin !== undefined) self.layoutPlugin.destroy(self);
                            
                            // Initialize new layout plugin.
                            self.layoutPlugin = layouts[name];
                            self.layoutPlugin.initialize(self);
                        }
                        else if (window.console) {
                            console.warn('Attempted to use Chatmore layout that does not exist: ' + name);
                        }
                    },
                    //
                    // Event binding methods.
                    //
                    // Bind event 'localMessage'.  Signature: callback(e, msg)
                    onLocalMessage: function (callback) {
                        self.ircElement.on('localMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'stateChanged'.  Signature: callback(e, state)
                    onStateChanged: function (callback) {
                        self.ircElement.on('stateChanged.chatmore', function (e) {
                            callback.call(self.ircElement, e, self.irc.state);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'processingMessage'.  Signature: callback(e, msg)
                    onProcessingMessage: function (callback) {
                        self.ircElement.on('processingMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'processedMessage'.  Signature: callback(e, msg)
                    onProcessedMessage: function (callback) {
                        self.ircElement.on('processedMessage.chatmore', function (e, msg) {
                            callback.call(self.ircElement, e, msg);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'sendingMessage'.  Signature: callback(e, rawMsg, resendCount)
                    onSendingMessage: function (callback) {
                        self.ircElement.on('sendingMessage.chatmore', function (e, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'sentMessage'.  Signature: callback(e, rawMsg, resendCount)
                    onSentMessage: function (callback) {
                        self.ircElement.on('sentMessage.chatmore', function (e, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'errorSendingMessage'.  Signature: callback(e, xhr, rawMsg, resendCount)
                    onErrorSendingMessage: function (callback) {
                        self.ircElement.on('errorSendingMessage.chatmore', function (e, xhr, rawMsg, resendCount) {
                            callback.call(self.ircElement, e, xhr, rawMsg, resendCount);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'activatingClient'.  Signature: callback(e, stage, message, params)
                    onActivatingClient: function (callback) {
                        self.ircElement.on('activatingClient.chatmore', function (e, stage, message, params) {
                            callback.call(self.ircElement, e, stage, message, params);
                        });
                        return self.ircElement;
                    },
                    // Bind event 'deactivatingClient'.  Signature: callback(e)
                    onDeactivatingClient: function (callback) {
                        self.ircElement.on('deactivatingClient.chatmore', function (e) {
                            callback.call(self.ircElement, e);
                        });
                        return self.ircElement;
                    }
                }
            };
    
            //
            // Initialization.
            //
            // Setup layout.
            self.ircElement
                .empty()
                .off()
                .data('chatmore', self); // Persist object in DOM element.
    
            self.layoutPlugin.initialize(self);
    
            // Client command aliases.
            self.cmdDefs.j = self.cmdDefs.join;
            self.cmdDefs.k = self.cmdDefs.kick;
            self.cmdDefs.l = self.cmdDefs.leave;
            self.cmdDefs.m = self.cmdDefs.msg;
            self.cmdDefs.n = self.cmdDefs.notice;
            self.cmdDefs.q = self.cmdDefs.query;
    
            // Setup chatmore event handlers.
            self.ircElement
                .on('localMessage.chatmore', function (e, message, type, data) {
                    if (window.console) console.log('UI event: localMessage');
                    switch (data.code) {
                    case 'R1':
                        // Retrying registration with new nick.
                        self.writeTmpl('retryRegistration', {});
                        break;
                        
                    case 'RE1':
                        // Registration failed.  Abort activation.
                        var m = data.maxRegistrationAttempts > 1 ?
                            'Registration failed.  Unable to register with a unique nickname after ' + data.maxRegistrationAttempts + ' attempts.  Please reconnect with a unique nickname.' :
                            'Registration failed.  Please reconnect with a unique nickname.';
                        self.writeTmpl(type, { message: m });
                            
                        self.enableAutoReactivate = false;
                        self.irc.deactivateClient();
                        break;
                    
                    default:
                        self.writeTmpl(type, { message: message });
                    }
                    
                    self.layoutPlugin.onLocalMessage(self, message, type, data);
                })
                .on('processingMessage.chatmore', function (e, msg) {
                    if (msg.type === 'recv') {
                        // Ensure user is in user state.
                        self.irc.state.addUser(msg.prefixNick);
    
                        // ERR_NICKNAMEINUSE
                        if (msg.command === '433') {
                            self.writeTmpl('nickInUse', { msg: msg });
                        }
                    }
                    
                    self.layoutPlugin.onProcessingMessage(self, msg);
                })
                .on('processedMessage.chatmore', function (e, msg) {
                    if (msg.type === 'recv') {
                        switch (msg.command) {
                        case 'PRIVMSG':
                            if (self.stricmp(msg.info.target, self.irc.state.nick) === 0)
                                self.writeTmpl(msg.info.isAction ? 'incomingPrivateAction' : 'incomingPrivateMsg', { msg: msg });
                            else
                                self.writeTmpl(msg.info.isAction ? 'incomingChannelAction' : 'incomingChannelMsg', { msg: msg });
                            break;
                        
                        case 'NOTICE':
                            if (self.stricmp(msg.info.target, self.irc.state.nick) === 0)
                                self.writeTmpl('incomingPrivateNotice', { msg: msg });
                            else
                                self.writeTmpl('incomingChannelNotice', { msg: msg });
                            break;
                            
                        case 'JOIN':
                            self.writeTmpl('join', { msg: msg });
    
                            // Auto-query newly joined channel.
                            if (self.stricmp(msg.prefixNick, self.irc.state.nick) === 0) {
                                self.queryTarget(msg.info.channel);
                            }
    
                            break;
                            
                        case 'PART':
                            self.writeTmpl('leave', { msg: msg });                        
                            break;
                            
                        case 'KICK':
                            var kickMsg = $.extend(true, { }, msg);
                            delete kickMsg.info.kicks;
                            $.each(msg.info.kicks, function (i, kick) {
                                kickMsg.info.kick = kick;
                                self.writeTmpl('kick', { msg: kickMsg });
                            });
                            break;
                            
                        case 'MODE':
                            self.writeTmpl('mode', { msg: msg });
                            break;
                        
                        case 'NICK':
                            self.writeTmpl('nick', { msg: msg });
                                                    
                            // If selected target's nick changes, update target.
                            if (self.irc.target() !== undefined && self.stricmp(msg.prefixNick, self.irc.target()) === 0) {
                                self.queryTarget(msg.info.nick);
                            }
                            break;
                            
                        case 'TOPIC':
                            self.writeTmpl('changeTopic', { msg: msg });
                            break;
                            
                        case 'QUIT':
                            self.writeTmpl('quit', { msg: msg });
                            break;
                            
                        case 'ERROR':
                            self.writeTmpl('error', {
                                message: msg.info.message
                            });
                            break;
    
                        case '001': // Welcome
                            // Auto-join channels.
                            if (self.autoJoinChannels !== undefined && self.autoJoinChannels.length > 0) {
                                $.each(self.autoJoinChannels.sort(self.stricmp).reverse(), function (idx, channel) {
                                    if (window.console) console.log('Joining channel: ' + channel);
                                    self.irc.sendMsg('JOIN ' + channel);
                                });
                            }
                            break;
                            
                        case '252': // RPL_LUSEROP
                        case '253': // RPL_LUSERUNKNOWN
                        case '254': // RPL_LUSERCHANNELS
                            self.writeTmpl('serverMsg', {
                                number: msg.info.number,
                                message: msg.info.message
                            });
                            break;
                            
                        case '322': // RPL_LIST
                            self.writeTmpl('list', { msg: msg });
                            break;
                            
                        case '331': // RPL_NOTOPIC
                            self.writeTmpl('notopic', { msg: msg });
                            break;
                            
                        case '332': // RPL_TOPIC
                            self.writeTmpl('topic', { msg: msg });
                            break;
                            
                        case '333': // Topic set by
                            self.writeTmpl('topicSetBy', { msg: msg });
                            break;
                            
                        case '352': // RPL_WHOREPLY
                            self.writeTmpl('who', { msg: msg });
                            break;
                            
                        case '391': // RPL_TIME
                            self.writeTmpl('serverTime', { msg: msg });
                            break;
                            
                        case '403': // ERR_NOSUCHCHANNEL
                            self.writeTmpl('serverMsg', { message: msg.info.message });
                            break;
                            
                        case '477': // ERR_NOCHANMODES
                            self.writeTmpl('serverMsg', {
                                channel: msg.info.channel,
                                message: msg.info.message
                            });
                            break;
    
                        // Disregard these messages.
                        case '004': // RPL_MYINFO
                        case '005': // RPL_BOUNCE
                        case '323': // RPL_LISTEND
                        case '324': // RPL_CHANNELMODEIS
                        case '353': // RPL_NAMREPLY
                        case '366': // RPL_ENDOFNAMES
                        case '433': // ERR_NICKNAMEINUSE (handled in processingMessage)
                            break;
                            
                        default:
                            // Any other server message.
                            if (msg.info.message !== undefined) {
                                self.writeTmpl('serverMsg', { message: msg.info.message });
                            }
                            break;
                        }
                    }
                    
                    self.layoutPlugin.onProcessedMessage(self, msg);
                })
                .on('stateChanged.chatmore', function (e) {
                    if (window.console) {
                        console.log('UI event: stateChanged');
                        console.log(self.irc.state);
                    }
                    
                    var state = self.irc.state;
                    
                    if (self.prevState === undefined || self.stricmp(state.nick, self.prevState.nick) !== 0) {
                        // Nick changed.
                        if (window.console) console.log('Nick changed.');
                        var nickLabel = self.ircElement.find('.nickLabel');
                        nickLabel.fadeOut(null, function () {
                            nickLabel.text(state.nick);
                            nickLabel.fadeIn();
                        });
                    }
    
                    // Auto-query first channel if selected user/channel is no longer available.
                    var target = self.irc.target();
                    if (target !== undefined) {
                        var isChannel = self.isChannel(target);
                        if (isChannel && !(target in state.channels)) {
                            var channel = self.getJoinedChannels()[0];
                            if (window.console) console.log('Selected channel is no longer joined.  Selecting first channel: ' + channel);
                            self.queryTarget(channel);
                        }
                        else if (!isChannel && !(target in state.users)) {
                            var channel = self.getJoinedChannels()[0];
                            if (window.console) console.log('Selected user is no longer available.  Selecting first channel: ' + channel);
                            self.queryTarget(channel);
                        }
                    }
                    
                    self.layoutPlugin.onStateChanged(self);
                    
                    self.prevState = self.clone(self.irc.state);
                })
                .on('sendingMessage.chatmore', function (e, rawMsg, resendCount) {
                    self.layoutPlugin.onSendingMessage(self, rawMsg, resendCount);
                })
                .on('errorSendingMessage.chatmore', function (e, xhr, rawMsg, resendCount) {
                    if (window.console) {
                        console.warn('Error sending message: ' + rawMsg + ', resendCount: ' + resendCount);
                        console.warn(xhr);
                    }
                    self.layoutPlugin.onErrorSendingMessage(self, xhr, rawMsg, resendCount);

                    if (resendCount == self.irc.options.maxResendAttempts) {
                        // Give user error that a message could not be sent after max attempts.
                        self.writeTmpl('error', { message: 'Unable to send message: ' + rawMsg });
                    }
                    else if (resendCount == 2) {
                        // Give user warning that a message could not be sent after a second attempt.
                        self.writeTmpl('error', { message: 'Error sending message to server, will try again: ' + rawMsg });
                    }
                })
                .on('activatingClient.chatmore', function (e, stage, message, params) {
                    switch (stage) {
                    case 'start':
                        if (window.console) console.log('UI event: activatingClient start');
                        self.isPendingActivation = true;
                        self.ircElement.find('.userEntry').focus();
                        break;
                        
                    case 'connecting':
                        if (window.console) console.log('UI event: activatingClient connecting');
                        var server = params.server + (params.port != 6667 ? (':' + params.port) : '');
                        self.writeTmpl('clientMsg', { message: 'Connecting to IRC server ' + server });
                        break;
                        
                    case 'resuming':
                        if (window.console) console.log('UI event: activatingClient resuming');
                        var server = params.server + (params.port != 6667 ? (':' + params.port) : '');
                        self.writeTmpl('clientMsg', { message: 'Resuming existing IRC connection to ' + server });
    
                        // Auto-join channels.
                        var channels = self.autoJoinChannels.sort(self.stricmp);
                        if (channels.length > 0) {
                            $.each(channels, function (idx, channel) {
                                if (window.console) console.log('Rejoining channel: ' + channel);
                                self.irc.sendMsg('JOIN ' + channel);
                                self.irc.sendMsg('NAMES ' + channel);
                            });
    
                            // Auto-query first channel.
                            self.queryTarget(channels[0]);
                        }
                        break;
                        
                    case 'activated':
                        if (window.console) console.log('UI event: activatingClient activated');
                        self.ircElement
                            .removeClass('deactivated')
                            .addClass('activated');
                        self.reactivateAttempts = 0;
                        self.enableAutoReactivate = true;
                        self.isPendingActivation = false;
                        break;
    
                    case 'error':
                        if (window.console) console.log('UI event: activatingClient error');
                        self.isPendingActivation = false;
                        self.writeTmpl('error', { message: message });
                        break;
                    }
                    
                    self.layoutPlugin.onActivatingClient(self, stage, message, params);
                })
                .on('deactivatingClient.chatmore', function () {
                    if (window.console) console.log('UI event: deactivatingClient');
                    self.ircElement
                        .removeClass('activated')
                        .addClass('deactivated');
                    
                    if (self.enableAutoReactivate) {
                        // Attempt reactivation.
                        if (self.reactivateAttempts < self.options.reactivateAttempts) {
                            //self.freezeSideBar = true;
                            self.isPendingActivation = true;
                            self.writeTmpl('error', { message: 'Server connection lost.  Retrying connection in ' + self.options.reactivateDelay + ' seconds...  Enter /quit to abort.' });
    
                            setTimeout(function () {
                                if (self.enableAutoReactivate) {
                                    self.reactivateAttempts++;
                                    self.irc.activateClient();
                                }
                            }, self.options.reactivateDelay * 1000);
                        }
                        else {
                            self.isPendingActivation = false;
                            self.writeTmpl('error', { message: 'Server connection lost and will not reconnect.  Sorry about that.' });
                            //self.freezeSideBar = false;
                        }
                    }
                    else {
                        self.isPendingActivation = false;
                        self.writeTmpl('error', { message: 'Server connection closed.' });
                        //self.freezeSideBar = false;
                    }
                    
                    self.layoutPlugin.onDeactivatingClient(self);
                });
                
            // Setup user event handlers.
            $.each([ 'onStateChanged', 'onLocalMessage', 'onProcessingMessage', 'onProcessedMessage', 'onSendingMessage',
                'onErrorSendingMessage', 'onSentMessage', 'onActivatingClient', 'onDeactivatingClient' ],
                function (idx, event) {
                    if (event in options) {
                        self.ircElement.chatmore(event, options[event]);
                    }
                }
            );
                        
            // Create chatmore client.
            self.irc = new chatmore(self.ircElement[0], options);
            if (options.activateImmediately) self.irc.activateClient();
            
            return self.ircElement;
        }
        else {
            // Invoke named method against chatmoreUI object.
            var method = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            var chatmoreSelf = $(this).data('chatmore');
            return chatmoreSelf.methods[method].apply(chatmoreSelf, args);
        }
    };
})();
// Default layout plugin for Chatmore.
(function () {
    //
    // Private static variables.
    //
    var layout;
    
    // IRC client message templates.
    var templates = {
        title: '<span>{{if messageCount == 1}}A new message has arrived! -- ' +
            '{{else messageCount > 1}}${messageCount} new messages have arrived! -- ' +
            '{{/if}}' +
            '${self.options.title} - ${self.irc.state.server}:${self.irc.state.port}</span>',
        timestamp: '<span class="timestamp" title="${self.getLongTimestamp()}">[${self.getShortTimestamp()}]&nbsp;</span>',
        bullet: '&bull;&bull;&bull;',
        notePrefix: '<span class="prefix">{{tmpl "bullet"}}</span>',
        error: '{{tmpl "timestamp"}}<span class="ERROR">' +
            '{{tmpl "notePrefix"}} <span class="message">${layout.htmlEncode(message)}</span>' +
            '</span>',
        usage: '{{tmpl "timestamp"}}<span class="usage">' +
            '{{tmpl "notePrefix"}} <span class="message">${layout.htmlEncode(message)}</span>' +
            '</span>',
        help: '{{tmpl "timestamp"}}<span class="help">' +
            '{{tmpl "notePrefix"}} <span class="message">${layout.htmlEncode(message)}</span>' +
            '</span>',
        serverMsg: '{{tmpl "timestamp"}}<span class="serverMsg">' +
            '{{tmpl "notePrefix"}} ' +
            '{{if channel}}&lt;<span class="channel">${channel}</span>&gt; {{/if}}' +
            '<span class="message">' +
            '{{if number}}${number} {{/if}}' +
            '${layout.htmlEncode(message)}</span>' +
            '</span>',
        clientMsg: '{{tmpl "timestamp"}}<span class="clientMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">${layout.htmlEncode(message)}</span>' +
            '</span>',
        outgoingChannelMsg: '{{tmpl "timestamp"}}<span class="channelMsg">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>&gt;</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        outgoingChannelAction: '{{tmpl "timestamp"}}<span class="channelMsg action">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>&gt; &bull; <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        outgoingChannelNotice: '{{tmpl "timestamp"}}<span class="channelNotice outgoing">' +
            '<span class="prefix">-<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        outgoingPrivateMsg: '{{tmpl "timestamp"}}<span class="privateMsg outgoing">' +
            '<span class="prefix">&bull;<span class="nick">${msg.info.target}</span>&bull;</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        outgoingPrivateAction: '{{tmpl "timestamp"}}<span class="privateMsg outgoing action">' +
            '<span class="prefix">&bull;<span class="nick">${msg.info.target}</span>&bull; <span class="nick">${msg.prefixNick}</span></span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        outgoingPrivateNotice: '{{tmpl "timestamp"}}<span class="privateNotice outgoing">' +
            '<span class="prefix">-<span class="nick">${msg.info.target}</span>-</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingChannelMsg: '{{tmpl "timestamp"}}<span class="channelMsg">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>&gt;</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingChannelAction: '{{tmpl "timestamp"}}<span class="channelMsg action">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.target}</span>&gt; &bull; <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingChannelNotice: '{{tmpl "timestamp"}}<span class="channelNotice incoming">' +
            '<span class="prefix">-<span class="channel">${msg.info.target}</span>:<span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingPrivateMsg: '{{tmpl "timestamp"}}<span class="privateMsg incoming">' +
            '<span class="prefix">&bull;<span class="nick">${msg.prefixNick}</span>&bull;</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingPrivateAction: '{{tmpl "timestamp"}}<span class="privateMsg incoming action">' +
            '<span class="prefix">&bull; <span class="nick">${msg.prefixNick}</span></span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        incomingPrivateNotice: '{{tmpl "timestamp"}}<span class="privateNotice incoming">' +
            '<span class="prefix">-<span class="nick">${msg.prefixNick}</span>-</span> ' +
            '<span class="message">${layout.htmlEncode(msg.info.text)}</span>' +
            '</span>',
        queryOff: '{{tmpl "timestamp"}}<span class="queryMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.isChannel(prevTarget)}}' +
                'You are no longer talking on channel <span class="channel">${prevTarget}</span>' +
            '{{else}}' +
                'Ending conversation with <span class="nick">${prevTarget}</span>' +
            '{{/if}}' +
            '</span></span>',
        query: '{{tmpl "timestamp"}}<span class="queryMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.isChannel(target)}}' +
                'You are now talking on channel <span class="channel">${target}</span>' +
            '{{else}}' +
                'Starting conversation with <span class="nick">${target}</span>' +
            '{{/if}}' +
            '</span></span>',
        join: '{{tmpl "timestamp"}}<span class="JOIN">' +
            '<span class="prefix">&lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> (${msg.prefixUser}@${msg.prefixHost}) has joined the channel</span>' +
            '</span>',
        leave: '{{tmpl "timestamp"}}<span class="PART">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> has left the channel{{if !!msg.info.comment}}: ${msg.info.comment}{{/if}}</span>' +
            '</span>',
        kick: '{{tmpl "timestamp"}}<span class="KICK">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.kick.channel}</span>&gt;</span> ' +
            '<span class="message">' +
            '{{if self.stricmp(self.irc.state.nick, msg.info.kick.nick) === 0}}' +
                'You have been kicked from the channel by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.kick.channel)}">${msg.prefixNick}</span>' +
            '{{else}}' +
                '<span class="nick ${layout.getColorizeCSSClass(self, msg.info.kick.nick, msg.info.kick.channel)}">${msg.info.kick.nick}</span> has been kicked from the channel by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.kick.channel)}">${msg.prefixNick}</span>' +
            '{{/if}}' +
            '{{if msg.info.comment !== undefined && msg.info.comment !== msg.prefixNick}}: ${layout.htmlEncode(msg.info.comment)}{{/if}}</span>' +
            '</span>',
        nick: '{{tmpl "timestamp"}}<span class="NICK">' +
            '{{tmpl "notePrefix"}} <span class="message">' +
            '{{if self.stricmp(self.irc.state.nick, msg.prefixNick) === 0}}' +
                'Nick changed to <span class="nick">${msg.info.nick}</span>' +
            '{{else}}' +
                '<span class="nick">${msg.prefixNick}</span> is now known as <span class="nick">${msg.info.nick}</span>' +
            '{{/if}}' +
            '</span></span>',
        nickInUse: '{{tmpl "timestamp"}}<span class="serverMsg">' +
            '{{tmpl "notePrefix"}} <span class="message">Nickname <span class="nick">${msg.info.nick}</span> is already in use.</span>' +
            '</span>',
        notopic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message no-decorate">No topic is set</span>' +
            '</span>',
        topic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message">' +
            '{{if msg.info.topic !== undefined}}' +
                '<span class="no-decorate">The current topic is:</span> <span class="topicMessage">${layout.htmlEncode(msg.info.topic)}</span>' +
            '{{else}}' +
                '<span class="message no-decorate">No topic is set</span>' +
            '{{/if}}' +
            '</span>' +
            '</span>',
        changeTopic: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message"><span class="no-decorate"><span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.channel)}">${msg.prefixNick}</span> ' +
            '{{if msg.info.topic == ""}}' +
                'has cleared the topic</span>' +
            '{{else}}' +
                'has changed the topic to: </span><span class="topicMessage">${layout.htmlEncode(msg.info.topic)}</span>' +
            '{{/if}}' +
            '</span></span>',
        topicSetBy: '{{tmpl "timestamp"}}<span class="TOPIC">' +
            '<span class="prefix">{{tmpl "bullet"}} &lt;<span class="channel">${msg.info.channel}</span>&gt;</span> ' +
            '<span class="message no-decorate">Topic set by <span class="nick ${layout.getColorizeCSSClass(self, msg.info.nick, msg.info.channel)}">${msg.info.nick}</span> on <span class="time">${self.formatTime(msg.info.time)}</span></span>' +
            '</span>',
        who: '{{tmpl "timestamp"}}<span class="WHO">' +
            '{{tmpl "notePrefix"}} <span class="message">WHO for <span class="nick ${layout.getColorizeCSSClass(self, msg.info.nick, msg.info.channel)}">${msg.info.nick}</span>: "${msg.info.realname}" ${msg.info.user}@${msg.info.host} on server ${msg.info.server}' +
            '</span>',
        serverTime: '{{tmpl "timestamp"}}<span class="TIME">' +
            '{{tmpl "notePrefix"}} <span class="message">Server time for <span class="server">${msg.info.server}</span>: <span class="time">${msg.info.timeString}</span></span>' +
            '</span>',
        quit: '{{tmpl "timestamp"}}<span class="QUIT">' +
            '{{tmpl "notePrefix"}} <span class="message">Signoff: <span class="nick">${msg.prefixNick}</span> (${msg.info.message})</span>' +
            '</span>',
        mode: '{{tmpl "timestamp"}}<span class="MODE">' +
            '{{tmpl "notePrefix"}} <span class="message">Mode change "<span class="modeString">${msg.info.mode}</span>" for ' +
            '{{if self.isChannel(msg.info.target)}}' +
                'channel <span class="channel">${msg.info.target}</span> ' +
                'by <span class="nick ${layout.getColorizeCSSClass(self, msg.prefixNick, msg.info.target)}">${msg.prefixNick}</span></span>' +
            '{{else}}'  +
                'user <span class="nick">${msg.info.target}</span> ' +
                'by <span class="nick">${msg.prefixNick}</span></span>' +
            '{{/if}}' +
            '</span>',
        list: '{{tmpl "timestamp"}}<span class="LIST">' +
            '{{tmpl "notePrefix"}} <span class="message"><span class="no-decorate"><span class="channel">${msg.info.channel}</span> (${msg.info.memberCount}): </span>${layout.htmlEncode(msg.info.topic)}</span>' +
            '</span>',
        retryRegistration: '{{tmpl "timestamp"}}<span class="clientMsg">' +
            '{{tmpl "notePrefix"}} <span class="message no-decorate">Retrying registration with nickname <span class="nick">${self.irc.state.nick}</span></span>' +
            '</span>'
    };

    //                  [-scheme---------][-hostname------------][-port][-path----------][-querystring-----------------------------------------------------][anchor]
    var linkifyRegex = /\b([a-z]{2,8}:\/\/([\w\-_]+(\.[\w\-_]+)*)(:\d+)?(\/[^\s\?\/<>]*)*(\?\&*([^\s=&#<>]+(=[^\s=&#<>]*)?(&[^\s=&#<>]+(=[^\s=&#<>]*)?)*)?)?(#\S+)?)/gi;

    // History of users for autoreply suggestions.
    var autoReplyList = [ ];

    // Autoreply index against autoReplyList array.
    var autoReplyIndex;
    
    // Auto complete setTimeout handle.
    var autoCompleteTimeoutHandle;
    
    // Auto complete list of term objects in the form:
    // { type: 'nick'|'channel', value: string }
    var autoCompleteList;
    
    // Auto complete suggest index against list of terms.
    var autoCompleteIndex;
    
    // Auto complete suggest index of value placed in userEntry.
    var autoCompleteTermIndex;

    // Current term string in userEntry when autoComplete presents suggestions.
    var autoCompleteTerm;
    
    // User provided term used for scanning autocomplete suggestions.
    // This contains the initial search term the user entered when scanAutoComplete() was called.
    var autoCompleteSpec;
    
    // Starting position of autoCompleteTerm.
    var autoCompleteTermPosition;
    
    // Function generated at runtime when tooltip is displayed.
    // Usage: autoCompleteTooltipScrollToTerm(termIndex);
    var autoCompleteTooltipScrollToTerm;

    // User entry history log.  First entry is scratch buffer from last unsent entry.
    var userEntryHistory = [''];
    var userEntryHistoryIndex;
    
    //
    // Private methods.
    //
    // Write HTML line to ircConsole.
    var writeLine = function (self, html) {
        layout.messageCount++;
        incrementNotificationMessageCount(self);

        var ircContent = self.ircElement.find('.ircConsole .content');
        var lineElement;

        var write = function (element) {
            // Is the console's scroll within 4 pixels from the bottom?
            var atBottom = layout.isAtBottom(self);
            
            // Roll off oldest line if at maximum lines.
            for (var lineCount = ircContent.find('.line').length; lineCount >= self.options.maximumConsoleLines; lineCount--) {
                ircContent.find('.line').first().remove();
            }

            // Auto decorate nicks and channels in message.
            var channel = element.find('.prefix .channel').text();
            element.closest('.channelMsg,.privateMsg,.TOPIC,.LIST,.serverMsg,.clientMsg').find('.message')
                .each(function () {
                    linkifyURLs(this);
                    decorateChannels(this);
                    decorateNicks(self, this, channel);
                });
            
            // Add doubleclick handler on nick and channel to auto-query.
            element.find('.nick,.channel')
                .hover(hoverClickableHandler, leaveClickableHandler)
                .dblclick(function () { dblclickChannelNickHandler.call(this, self); });
                
            // Detect if my nick was mentioned in a channel message.
            element.closest('.channelMsg').find('.message .nick')
                .filter(function () {
                    return self.irc.state !== undefined && self.stricmp($(this).text(), self.irc.state.nick) === 0;
                })
                .first()
                .filter(function () {
                    // Check if this message is written by me.  If I wrote it, skip highlighting.
                    var prefixNick = element.find('.prefix .nick').text();
                    return self.irc.state !== undefined && self.stricmp(prefixNick, self.irc.state.nick) !== 0;
                })
                .each(function () {
                    element.closest('.channelMsg').addClass('nickHighlight');
                });

            // Add line to console.
            var lineElement = $('<div class="line"/>')
                .attr('mc', layout.messageCount)
                .append(element)
                .appendTo(ircContent);
                
            if (!layout.isWindowFocused) {
                if (layout.blurMessageCount === (layout.messageCount - 1)) {
                    var content = self.ircElement.find('.ircConsole .content');
                    content.find('.line.viewed').removeClass('viewed');
                }
                lineElement
                    .addClass('new')
                    .css('opacity', '0.5');
            }
                
            // Auto scroll to bottom if currently at bottom.
            if (atBottom) layout.scrollToBottom(self);
            
            return lineElement;
        };
        
        if (typeof(html) === 'object') {
            $.each(html, function (i, html) {
                var element = $('<div/>').append(html);
                lineElement = write(element.contents());
            });
        }
        else {
            var element = $('<div/>').append(html);
            lineElement = write(element.contents());
        }
        
        return lineElement;
    };

    // Equivalent of find("*"), but only returns text nodes.
    // Returns jQuery object.
    var findTextNodes = function (node) {
        var textNodes = $();
        
        $(node).contents().each(function () {
            if (this.nodeType === 3) {
                textNodes = textNodes.add(this);
            }
            else {
                // Recurse children.
                var childNodes = findTextNodes(this);
                if (childNodes.length > 0)
                    textNodes = textNodes.add(childNodes);
            }
        });
    
        return textNodes;
    };

    // Filter findTextNodes to only those text nodes that qualify for decoration.
    // Returns jQuery object.
    var findTextNodesForDecoration = function (el) {
        return findTextNodes(el).filter(function () {
            var $node = $(this);
            // Exclude elements tagged with no-decorate class.
            return $(this).parents('.no-decorate').length === 0;
        });
    };
    
    // Convert URL patterns into HTML links.
    var linkifyURLs = function (el) {
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;

            // Use regex to isolate URL patterns, replace with hyperlink elements.
            var html = layout.htmlEncode($node.text()).replace(linkifyRegex, function (m, url) {
                modified = true;
                
                // Special case: strip trailing symbols that are probably not intended as part of the URL.
                trailingText = url.match(/[)>,\.;:'"]$/);
                if (trailingText !== null)
                    url = url.substring(url, url.length - trailingText[0].length);
                
                var n = $('<div/>')
                    .append($('<a/>')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .attr('class', 'no-decorate')
                        .text(url));
                        
                if (trailingText !== null)
                    n.append(document.createTextNode(trailingText[0]));
                
                return n.html();
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };
    
    // Decorate nicks found in text with span.
    var decorateNicks = function (self, el, channel) {
        var nicks;
        if (self.irc.state !== undefined) {
            nicks = $.map(self.irc.state.users, function (val, key) { return key; });
        }

        if (nicks === undefined || nicks.length === 0) return;
        
        // Convert array of nicks to regex expression.
        var nickExpr = $.map(nicks, function (nick) {
            // Escape regex symbols.
            return nick.replace(/([?*|.\^$()\[\]{}\\\/])/g, "\\$1");
        }).join('|');
        var re = new RegExp("\\b(" + nickExpr + ")\\b", 'ig');
        
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;
            var html = layout.htmlEncode($node.text()).replace(re, function (m, nick) {
                var colorizeNumber;
                if (channel !== undefined && self.isChannel(channel)) {
                    // Lookup nick's colorize number for given channel.
                    if (self.irc.state.channels[channel] !== undefined &&
                        self.irc.state.channels[channel].members[nick] !== undefined) {
                        colorizeNumber = self.irc.state.channels[channel].members[nick].colorizeNumber;
                    }
                }
                
                modified = true;

                if (colorizeNumber !== undefined) {
                    return '<span class="nick color' + colorizeNumber + ' no-decorate">' + nick + '</span>';
                }
                else {
                    return '<span class="nick no-decorate">' + nick + '</span>';
                }
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };

    // Decorate channel-like text with span.
    var decorateChannels = function (el) {
        findTextNodesForDecoration(el).each(function () {
            var $node = $(this);
            var modified = false;
            var html = layout.htmlEncode($node.text()).replace(/(^|[\s,:\cg])(#[^\s,:\cg]+)\b/g, function (m, text, channel) {
                modified = true;
                
                return text + '<span class="channel no-decorate">' + channel + '</span>';
            });
            
            if (modified) {
                var $prevSibling = $node.prev();
                var $parent = $node.parent();
                var $newNode = $('<span>' + html + '</span>');

                $node.remove();

                if ($prevSibling.length)
                    $prevSibling.after($newNode);
                else
                    $parent.prepend($newNode);
            }
        });
    };

    // Get colorize number associated with nick in channel from state object.
    var getColorizeNumber = function (self, nick, channel) {
        var channelDesc = self.irc.state.channels[channel];
        if (channelDesc === undefined) return;
        
        return channelDesc.members[nick] !== undefined ?
            channelDesc.members[nick].colorizeNumber : undefined;
    };

    // Add nick to recent message users list for use with autoreply suggestions.
    var addToAutoReplyList = function (self, nick) {
        if (self.stricmp(nick, self.irc.state.nick) !== 0) {
            autoReplyList = $.grep(autoReplyList, function (val) {
                // Remove from array, if exists.
                return self.stricmp(val, nick) !== 0;
            });
            autoReplyList.unshift(nick);
            
            // Preserve placement of auto complete reply index so that additions to the list don't interfere.
            if (autoReplyIndex !== undefined) autoReplyIndex++;
        }
    };

    // Accept presented autoreply.
    var acceptAutoReply = function (self) {
        if (autoReplyIndex !== undefined) {
            // Accept autoreply.
            // User entry value and caret are already set from incrementAutoReply.
            // Clear autoreply state.
            autoReplyIndex = undefined;

            self.ircElement.find('.userEntry')
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };

    // Reject presented autoreply.
    var rejectAutoReply = function (self) {
        if (autoReplyIndex !== undefined) {
            // Clear user entry and autoreply state.
            autoReplyIndex = undefined;

            self.ircElement.find('.userEntry')
                .val('')
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };
                
    // Iterate over autoreply possibilities.
    var incrementAutoReply = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();
        var s = $userEntry.val();
            
        if (s === '' || autoReplyIndex !== undefined) {
            // When user entry is blank, suggest autoreply from recent users list.
            if (autoReplyList.length) {
                if (autoReplyIndex === undefined) autoReplyIndex = 0;
                
                // Suggest quick send message to next recent sender.
                var recipient = autoReplyList[autoReplyIndex];
                var s2 = '/msg ' + recipient + ' ';
                $userEntry.val(s2);
                $userEntry[0].selectionStart = $userEntry[0].selectionEnd = s2.length;
                autoReplyIndex++;
                if (autoReplyIndex >= autoReplyList.length) autoReplyIndex = 0;
                
                // Show autoreply suggestion as tooltip.
                $userEntry
                    .tooltip('close')
                    .tooltip('option', 'content', 'Reply to <span class="activeSuggestion term"><span class="nick">' + recipient + '</span></span>')
                    .tooltip('open');
            }
        }
    };

    var queueScanAutoComplete = function (self) {
        cancelQueuedScanAutoComplete();
        
        autoCompleteTimeoutHandle = setTimeout(function () {
            autoCompleteTimeoutHandle = undefined;
            scanAutoComplete(self);
        }, 200);
    };
    
    var cancelQueuedScanAutoComplete = function () {
        if (autoCompleteTimeoutHandle !== undefined) {
            clearTimeout(autoCompleteTimeoutHandle);
            autoCompleteTimeoutHandle = undefined;
        }
    };
    
    // Check for keyword at cursor for an autocomplete suggestion.
    var scanAutoComplete = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();
        var value = $userEntry.val();
        var position = $userEntry[0].selectionStart;
        var matches = [];

        // If cursor is at beginning, cancel autocomplete.
        if (position > 0) {
            // Position must be on a word boundary.
            // If cursor is in the middle of a word or not on a word at all, cancel autosuggest.
            // Keyword may be bounded by white space or certain punctuation.
            var lvalue = value.substr(0, position);
            var termMatch = /([^\s,\.\/\\]+)$/.exec(lvalue);
            var rvalue = value.substr(position);
            
            if (termMatch !== null && /^([\s,\.\/\\]|$)/.test(rvalue)) {
                // term is valid.
                autoCompleteSpec = autoCompleteTerm = termMatch[1];
                autoCompleteTermPosition = position - autoCompleteSpec.length;
                var term = autoCompleteTerm.toLowerCase();
                
                // Scan nicks.
                var channel = self.irc.state.channels[self.irc.target()];
                if (channel !== undefined) {
                    $.each(channel.members, function (nick) {
                        if (term === nick.substr(0, term.length).toLowerCase() && nick !== self.irc.state.nick) {
                            matches.push({ type: 'nick', value: nick });
                        }
                    });
                }
                
                // Scan channels.
                $.each(self.irc.state.channels, function (channel) {
                    if (term === channel.substr(0, term.length).toLowerCase()) {
                        matches.push({ type: 'channel', value: channel });
                    }
                });
            }
        }

        if (matches.length === 0) {
            clearAutoComplete(self);
        }
        else {
            // Prep match list.
            matches.sort(function (a, b) { return a.value.localeCompare(b.value) });
            if (window.console) {
                console.log('autoComplete matches:');
                console.log(matches);
            }
            
            // Show tooltip with first match.
            autoCompleteList = matches;
            autoCompleteIndex = 0;
            autoCompleteTermIndex = undefined;
            updateAutoCompleteTooltip(self);
            
            // Hack to make incrementAutoComplete() pick up the first term on Tab.
            autoCompleteIndex = -1;
        }
    };
    
    var updateAutoCompleteTooltip = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();

        if (autoCompleteList.length > 0) {
            // Show all suggestions in tooltip.
            // Decorate suggestion text based on type.
            var tooltipContentList = [];

            for (var matchIndex = 0; matchIndex < autoCompleteList.length; matchIndex++) {
                var match = autoCompleteList[matchIndex];
                var content = layout.htmlEncode(match.value); //$('<span />').text(match.value).html();
                
                if (match.type === 'nick') {
                    var colorizeNumber = getColorizeNumber(self, match.value, self.irc.target());
                    content = '<span class="nick color' + colorizeNumber + '">' + content + '</span>';
                }
                else if (match.type === 'channel')
                    content = '<span class="channel">' + content + '</span>';
                
                // Identify the 'active' suggestion placed in userEntry.
                if (autoCompleteTermIndex !== undefined && match.value === autoCompleteList[autoCompleteTermIndex].value)
                    content = '<span class="activeSuggestion term">' + content + '</span>';
                else
                    content = '<span class="inactiveSuggestion term">' + content + '</span>';
                
                tooltipContentList.push(content);
            }
            
            var tooltipContent = tooltipContentList.join(',&nbsp;');

            $userEntry
                .tooltip('option', 'content', tooltipContent)
                .tooltip('open');

            autoCompleteTooltipScrollToTerm(autoCompleteTermIndex);
        }
        else {
            $userEntry
                .tooltip('option', 'content', '')
                .tooltip('close');
        }
    };
    
    var incrementAutoComplete = function (self, step) {
        if (autoCompleteList !== undefined) {
            if (step === undefined) step = 1;
            
            // Parse out old term from userEntry.
            var $userEntry = self.ircElement.find('.userEntry').first();
            var value = $userEntry.val();
            var lvalue = value.substr(0, autoCompleteTermPosition);
            var rvalue = value.substr(autoCompleteTermPosition + autoCompleteTerm.length);

            // Get next suggested term.
            autoCompleteIndex = autoCompleteTermIndex = (autoCompleteIndex + step) % autoCompleteList.length;
            autoCompleteTerm = autoCompleteList[autoCompleteIndex].value;
            if (lvalue.length === 0) autoCompleteTerm += ': ';

            // Place term into userEntry.
            var newValue = lvalue + autoCompleteTerm + rvalue;
            $userEntry.val(newValue);
            $userEntry[0].selectionStart = $userEntry[0].selectionEnd = autoCompleteTermPosition + autoCompleteTerm.length;

            // Update tooltip.
            updateAutoCompleteTooltip(self);
        }
    };

    var rejectAutoComplete = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();

        if (autoCompleteTerm !== undefined) {
            // Parse out old term from userEntry.
            var value = $userEntry.val();
            var lvalue = value.substr(0, autoCompleteTermPosition);
            var rvalue = value.substr(autoCompleteTermPosition + autoCompleteTerm.length);
            
            // Place original spec into userEntry.
            var newValue = lvalue + autoCompleteSpec + rvalue;
            $userEntry.val(newValue);
            $userEntry[0].selectionStart = $userEntry[0].selectionEnd = autoCompleteTermPosition + autoCompleteSpec.length;
        }
        
        autoCompleteList = undefined;
        autoCompleteIndex = undefined;
        autoCompleteTermIndex = undefined;
        autoCompleteTermPosition = undefined;
        autoCompleteTerm = undefined;
        
        $userEntry
            .tooltip('option', 'content', '')
            .tooltip('close');
    };
    
    var clearAutoComplete = function (self) {
        var $userEntry = self.ircElement.find('.userEntry').first();

        clearAutoCompleteState();
        
        $userEntry
            .tooltip('option', 'content', '')
            .tooltip('close');
    }

    var clearAutoCompleteState = function () {
        autoCompleteList = undefined;
        autoCompleteIndex = undefined;
        autoCompleteTermIndex = undefined;
        autoCompleteTermPosition = undefined;
        autoCompleteTerm = undefined;
    }

    var hoverClickableHandler = function () {
        $(this).addClass('ui-state-hover');
    };
    
    var leaveClickableHandler = function () {
        $(this).removeClass('ui-state-hover');
    };
    
    var dblclickChannelNickHandler = function (self) {
        if (self.irc.state.isActivated) {
            // Get text of element, ignoring child elements.
            var target = $(this)
                .clone()
                .children()
                .remove()
                .end()
                .text();
                
            // Unselect doubleclicked text.
            self.clearSelection();

            if (self.irc.state !== undefined && self.stricmp(target, self.irc.state.nick) !== 0) {
                if (self.isChannel(target)) {
                    // Check if joined to this channel.
                    if (self.irc.state !== undefined && self.irc.state.channels[target] === undefined)
                        self.sendLine('/join ' + target);
                    else
                        self.queryTarget(target);
                }
                else {
                    self.queryTarget(target);
                }

                self.ircElement.find('.userEntry').focus();
            }
        }
    };

    var refreshSideBar = function (self) {
        if (!layout.freezeSideBar) {
            // TODO: Incrementally update channel/member lists to avoid rendering flaws of concurrent actions,
            // such as incoming messages and user actions both changing state.
            var channelList = self.ircElement.find('.sideBar ul.channelList');
            var originalScrollTop = channelList[0].scrollTop;
                
            channelList.empty();

            $.each(self.getJoinedChannels(), function (i, channel) {
                var channelDesc = self.irc.state.channels[channel];
                var memberCount = self.getLength(channelDesc.members);
                var channelElement = $('<li><span class="channel">' + channel + '</span><span class="memberCount">(' + memberCount + ')</span><span class="leaveButton" title="Leave channel"></span></li>')
                    // Set topic as tooltip.
                    .find('.channel')
                        .attr('title', (channelDesc.topic !== undefined) ? channelDesc.topic : 'No topic set')
                        .end()
                    // Setup leave channel icon.
                    .find('.leaveButton')
                        .click(function () {
                            if (self.irc.state.isActivated) {
                                $(this).parent('li').addClass('leaving');
                                self.sendLine('/leave ' + channel);
                            }
                        })
                        .end()
                    .appendTo(channelList);
                
                var memberList = $('<ul class="memberList"/>')
                    .appendTo(channelElement);
                    
                $.each(self.getChannelMembers(channel), function (i, member) {
                    var memberDesc = channelDesc.members[member];
                    var colorizeNumber = memberDesc.colorizeNumber;
                    $('<li><span class="mode">' + memberDesc.mode + '</span><span class="nick color' + colorizeNumber + '">' + member + '</span></li>')
                        .appendTo(memberList);
                });
            });
            
            // Scroll back to original spot.
            channelList[0].scrollTop = originalScrollTop;
            
            // Apply doubleclick handler to channels and nicks.
            channelList.find('.nick,.channel')
                .hover(hoverClickableHandler, leaveClickableHandler)
                .dblclick(function () { dblclickChannelNickHandler.call(this, self); });
        }
    };

    // Resize elements to proper alignment based on ircConsole's dimensions.
    var alignUI = function (self) {
        var ircConsole = self.ircElement.find('.ircConsole');
        var ircContent = self.ircElement.find('.ircConsole .content');
        var userEntrySection = self.ircElement.find('.userEntrySection');
        var userEntryLine = self.ircElement.find('.userEntryLine');
        var userEntry = self.ircElement.find('.userEntry');
        var sideBar = self.ircElement.find('.sideBar');
        var channelList = sideBar.find('.channelList');
        ircContent
            .width(ircConsole.width())
            .height(ircConsole.height());
        userEntrySection
            .outerWidth(ircConsole.outerWidth());
        userEntryLine
            .width(userEntrySection.width());
        userEntry.outerWidth(userEntryLine.width());
        sideBar.outerHeight(ircConsole.outerHeight() + userEntrySection.outerHeight());
        channelList.height(sideBar.height());
    };
    
    var compileTemplates = function () {
        $.each(templates, function (name, tmpl) {
            $.template(name, tmpl);
        });
    };

    // Update browser title from template.
    var refreshTitle = function (self) {
        var newTitle = $.tmpl('title', {
            self: self,
            layout: layout,
            messageCount: layout.notificationMessageCount
        }).text();

        if (newTitle !== document.title) document.title = newTitle;
    };

    // Update title when notifications occur and user isn't focused on the browser.
    var incrementNotificationMessageCount = function (self) {
        if (!layout.isWindowFocused) {
            layout.notificationMessageCount++;
            refreshTitle(self);
        }
    };

    var getChannelsFromHash = function () {
        var channels = document.location.hash.split(',');
        if (channels[0].length === 0) return [ ];
        else return channels;
    };
    
    var setHashWithChannels = function (channels) {
        var hash = channels.sort().join(',');
        if (document.location.hash !== hash) document.location.hash = hash;
    };

    var newViewKey = function () {
        return Math.random().toString(36).substr(2, 8);
    };
    
    var getQueryString = function () {
        return location.search.substring(1);
    };
    
    // http://stackoverflow.com/a/647272/3347
    var parseQueryString = function (queryString) {
        var result = { };
        var re = /([^&=]+)=([^&]*)/g;
        var m;
        
        while (m = re.exec(queryString)) {
            result[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
        }

        return result;
    };
    
    toQueryString = function (arr) {
        var args = $.map(arr, function (val, key) {
            if (val === undefined || val === null)
                return encodeURIComponent(key);
            else
                return encodeURIComponent(key) + '=' + encodeURIComponent(val);
        });
        return args.join('&');
    };

    //
    // Public methods.
    //
    layout = {
        messageCount: 0,                    // Console message counter.
        notificationMessageCount: 0,        // Number of messages received while not focused on browser.
        blurMessageCount: undefined,        // Message count at time of blur event.
        isWindowFocused: true,
        freezeSideBar: false,               // True to disregard UI updates when calling refreshSideBar.
        warnOnUnload: true,                 // Warn user when attempting to navigate away from page.

        initialize: function (self, options) {
            self.ircElement
                .addClass('chatmore')
                .addClass('-fullpage-layout')
                .addClass('ui-widget')
                .append($(
                    '<div style="float:left;overflow:hidden">' +
                        '<div class="ircConsole ui-widget-content ui-corner-tl"><div class="content ui-corner-all"/></div>' +
                        '<div class="userEntrySection ui-widget-content ui-corner-bl">' +
                            '<div class="userEntryModeLine">' +
                                '<div class="activationIndicator"/>' +
                                '<div class="nickLabel nick"/>' +
                                '<div class="targetFragment" style="display:none"><div class="targetLabel"/></div>' +
                            '</div>' +
                            '<div class="userEntryLine"><input type="text" class="userEntry" /></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="sideBar ui-widget ui-widget-content ui-corner-right"><ul class="channelList"/></div>'
                ));
            
            alignUI(self);
            compileTemplates(self);

            // Parse hash string for channels.
            var channels = getChannelsFromHash();
            if (channels.length > 0) self.autoJoinChannels = channels;

            // Track browser window focus.
            $(window)
                .on('focus.chatmore_default', function () {
                    // Restore title when user comes back to the window.
                    setTimeout(function () {
                        layout.notificationMessageCount = 0;
                        refreshTitle(self);
                    }, 200);
                    
                    if (!layout.isWindowFocused) {
                        layout.isWindowFocused = true;
                        self.ircElement.find('.userEntry').focus();
                        
                        // Indicate new messages since blur.
                        if (layout.blurMessageCount) {
                            var msgElements = self.ircElement.find('.ircConsole .content > .line.new');
                            msgElements.fadeTo(2000, 1, 'easeOutExpo', function () {
                                msgElements
                                    .removeClass('new')
                                    .addClass('viewed');
                            });
                        }
                        
                        layout.blurMessageCount = undefined;
                    }
                })
                .on('blur.chatmore_default', function () {
                    // Start tracking new messages when losing focus.
                    layout.isWindowFocused = false;
                    layout.blurMessageCount = layout.messageCount;
                })
                .on('resize.chatmore_default', function () {
                    // Resize client to match window.
                    layout.resize(self);
                })
                .on('beforeunload.chatmore_default', function () {
                    // Provide popup warning when navigating away from this page.
                    if (layout.warnOnUnload) return 'You are about to navigate away from the Chatmore IRC client, which may disconnect from your session.';
                });
            
            // Setup user entry event handlers.
            var keydownWasHandled = false;

            self.ircElement.find('.userEntry')
                .keydown(function (e) {
                    var $userEntry = $(this);
                    keydownWasHandled = false;

                    if (!e.altKey && !e.ctrlKey && !e.shiftKey) {
                        // Cancel pending scanAutoComplete() to prevent typing conflicts.
                        cancelQueuedScanAutoComplete();
                        
                        if (e.keyCode === 13 /* Enter */) {
                            // Send message.
                            // Add new scratch line to user entry history.
                            userEntryHistory.unshift('');
                        
                            self.sendLine($userEntry.val());
                            $userEntry.val('');
                            
                            // Reset user entry history index.
                            self.userEntryHistoryIndex = undefined;

                            // Clear any autocomplete suggestions.
                            if (autoReplyIndex !== undefined)
                                rejectAutoReply(self);
                            else
                                clearAutoComplete(self);
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode === 27 /* Escape */) {
                            if (autoReplyIndex !== undefined)
                                rejectAutoReply(self);
                            else
                                rejectAutoComplete(self);
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode == 8 /* Backspace */ || e.keyCode == 46 /* Delete */) {
                            // Backspace/Delete rejects an autoreply.
                            if (autoReplyIndex !== undefined) {
                                rejectAutoReply(self);
                                
                                keydownWasHandled = true;
                                return false;
                            }
                                
                            // Cancel autocomplete suggestion, then rescan on backspace or delete.
                            queueScanAutoComplete(self);
                        }
                        else if (e.keyCode === 9 /* Tab */) {
                            // Tab through auto replies if line is empty.
                            if ($userEntry.val() === '' || autoReplyIndex !== undefined) {
                                incrementAutoReply(self);
                            }
                            // Scan for autocomplete if no suggestion is present.
                            else if (autoCompleteList === undefined) {
                                scanAutoComplete(self);
                                incrementAutoComplete(self);
                            }
                            // Accept a presented autocomplete suggestion.
                            else {
                                incrementAutoComplete(self);
                            }
                            
                            keydownWasHandled = true;
                            return false;
                        }
                        else if (e.keyCode === 38 /* Arrow up */ || e.keyCode === 40 /* Arrow down */) {
                            if (userEntryHistoryIndex === undefined && userEntryHistory.length > 1) {
                                // Start browsing history, if any exists.
                                userEntryHistoryIndex = 0;
                            }
                            
                            if (userEntryHistoryIndex !== undefined) {
                                // Ensure no auto complete is presented.
                                rejectAutoReply(self);
                                clearAutoComplete(self);

                                if (e.keyCode === 38) {
                                    // Go to next oldest history entry.
                                    userEntryHistoryIndex++;
                                    if (userEntryHistoryIndex >= userEntryHistory.length)
                                        userEntryHistoryIndex = 0;
                                }
                                else {
                                    // Go to next newest history entry.
                                    userEntryHistoryIndex--;
                                    if (userEntryHistoryIndex < 0)
                                        userEntryHistoryIndex = userEntryHistory.length - 1;
                                }
                            
                                // Display history in user entry.
                                var entry = userEntryHistory[userEntryHistoryIndex];
                                $userEntry.val(entry);
        
                                // Place caret at end of line.
                                this.selectionStart = entry.length;
                                this.selectionEnd = this.selectionStart;
                            }
                            
                            keydownWasHandled = true;
                            return false;
                        }                    
                    }
                })
                .keypress(function (e) {
                    if (keydownWasHandled) {
                        keydownWasHandled = false;
                        return false;
                    }
                    
                    clearAutoCompleteState();

                    if (autoReplyIndex !== undefined) {
                        // Typing text will accept a presented autoreply.
                        acceptAutoReply(self);
                    }

                    // Store current entry in first history element as scratch buffer.
                    var $userEntry = $(this);
                    userEntryHistory[0] = $userEntry.val() + String.fromCharCode(e.which);

                    queueScanAutoComplete(self);
                })
                // Setup tooltip.
                .tooltip({
                    items: '.userEntry',
                    show: { effect: 'fade', duration: 250 },
                    position: { my: 'left top', at: 'left bottom' },
                    track: false,
                    open: function (e, ui) {
                        // Move tooltip div to inside ircElement so that CSS styles apply.
                        ui.tooltip.appendTo(self.ircElement);
                        
                        // Prepare delegate function for scrolling to term index.
                        autoCompleteTooltipScrollToTerm = function (termIndex) {
                            var $term = ui.tooltip.find('.term').eq(termIndex).each(function () {
                                var newScrollLeft = $(this).offset().left - parseInt($(this).css('margin-left')) - parseInt($(this).css('padding-left')) - ui.tooltip.offset().left - parseInt(ui.tooltip.css('padding-left')) + ui.tooltip.scrollLeft();
                                ui.tooltip
                                    .stop()
                                    .animate({ scrollLeft: newScrollLeft });
                            });
                        };
                    }
                })
                .focus();
            
            layout.resize(self);
        },
        destroy: function () {
            // Clean up.
            $(window).off('.chatmore_default');
        },
        writeTemplate: function (self, templateName, data) {
            if (templateName === 'outgoingPrivateMsg') {
                // For outgoing private messages to a user, record the target nick in autoreply list.
                if (!self.isChannel(data.msg.info.target)) {
                    addToAutoReplyList(self, data.msg.info.target);
                }
            }

            data.self = self;
            data.layout = layout;
            
            var el = $('<div/>')
                .append($.tmpl(templateName, data));
            return writeLine(self, el.html());
        },
        htmlEncode: function (value) {
            //return $('<div/>').text(value).html();
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        },
        resize: function (self, width, height) {
            if (width && height) {
                var ircConsole = self.ircElement.find('.ircConsole');
                var sideBar = self.ircElement.find('.sideBar');
                var userEntrySection = self.ircElement.find('.userEntrySection');
                
                ircConsole
                    .outerWidth(width - sideBar.outerWidth())
                    .outerHeight(height - userEntrySection.outerHeight());
                
                alignUI(self);
            }
            else {
                // Resize to fit.
                var parent = self.ircElement.parent();
                var atBottom = layout.isAtBottom(self);
                
                layout.resize(self,
                    $(window).width() - parent.outerWidth() + parent.width(),
                    $(window).height() - parent.outerHeight() + parent.height());
                
                if (atBottom) layout.scrollToBottom(self);
            }
        },
        scrollToBottom: function (self) {
            var ircContent = self.ircElement.find('.ircConsole .content');
            ircContent[0].scrollTop = ircContent[0].scrollHeight;
        },

        //
        // Property getters.
        //
        // Determine if IRC console is scrolled to the bottom.
        isAtBottom: function (self) {
            var ircContent = self.ircElement.find('.ircConsole .content');
            return (ircContent[0].scrollTop + 4) >= (ircContent[0].scrollHeight - ircContent[0].clientHeight);
        },
        
        //
        // Event handlers.
        //
        onStateChanged: function (self) {
            //if (window.console) console.log('Plugin event: stateChanged');
            refreshSideBar(self);
            setHashWithChannels(self.irc.state.getChannels());
        },
        onLocalMessage: function (self, message, type, data) { },
        onProcessingMessage: function (self, msg) { },
        onProcessedMessage: function (self, msg) {
            //if (window.console) console.log('Plugin event: processedMessage');
            if (msg.type === 'servermsg' && msg.code === 402) {
                if (window.console) console.warn('Got session deleted error.  Generating new viewKey and reactivating...');
                
                // Session deleted error during activation.  Generate new viewKey and reactivate.
                var query = parseQueryString(getQueryString());
                query.viewKey = newViewKey();

                if (window.history.replaceState) {
                    // HTML5: Restart client with new viewKey without reloading; update URL to reflect viewKey.
                    var updatedUrl = document.location.pathname + '?' + toQueryString(query) + document.location.hash;
                    window.history.replaceState(null, document.title, updatedUrl);

                    var options = $.extend({ }, self.options);
                    options.viewKey = query.viewKey;
                    options.channels = getChannelsFromHash();
                    $('#chatmore')
                        .chatmore(options)
                        .chatmore('resize');
                }
                else {
                    // HTML4: Redirect back with new viewKey.
                    layout.warnOnUnload = false;
                    document.location.search = '?' + toQueryString(query);
                }
            }
            else {
                switch (msg.command) {
                case 'PRIVMSG':
                    if (self.stricmp(msg.info.target, self.irc.state.nick) === 0) {
                        if (!msg.info.isAction) {
                            // Add this sender to the history of users.
                            addToAutoReplyList(self, msg.prefixNick);
                        }
                    }
                    break;
                case 'NOTICE':
                    if (self.stricmp(msg.info.target, self.irc.state.nick) === 0) {
                        // Add this sender to the history of users.
                        addToAutoReplyList(self, msg.prefixNick);
                    }
                    break;
                }
            }
        },
        onSendingMessage: function (self, rawMsg) { },
        onErrorSendingMessage: function (self, xhr, rawMsg) { },
        onSentMessage: function (self, rawMsg) { },
        onActivatingClient: function (self, stage, message, params) {
            if (stage === 'resuming' || stage === 'activated') {
                // Once activated, the sidebar can be refreshed.
                layout.freezeSideBar = false;
            }
        },
        onDeactivatingClient: function (self) {
            // Disable updates to the sidebar while in auto-reconnection state.
            if (self.enableAutoReactivate && self.reactivateAttempts < self.options.reactivateAttempts)
                layout.freezeSideBar = true;
            else
                layout.freezeSideBar = false;
        },

        //
        // Internal methods.
        //
        getColorizeCSSClass: function (self, nick, channel) {
            var number = getColorizeNumber(self, nick, channel);
            return number !== undefined ? 'color' + number : '';
        }
    };

    // Register layout.
    $.chatmore('layouts')['default'] = layout;
})();
